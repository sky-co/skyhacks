<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 896. Monotonic Array]]></title>
    <url>%2F2018%2F10%2F10%2FLeetCode%2FLeetCode-MonotonicArray%2F</url>
    <content type="text"><![CDATA[题目描述：An array is monotonic if it is either monotone increasing or monotone decreasing. An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j]. An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j]. Return true if and only if the given array A is monotonic. Example 1:12Input: [1,2,2,3]Output: true Example 2:12Input: [6,5,4,4]Output: true Example 3:12Input: [1,3,2]Output: false Example 4:12Input: [1,2,4,5]Output: true Example 5:12Input: [1,1,1]Output: true Note:121 &lt;= A.length &lt;= 50000-100000 &lt;= A[i] &lt;= 100000 题目大意：一个单调数组的定义就是数组元素单调递增或者单调递减。测试样例见题目描述 解题思路：对于n个元素数组来说判断是否递增/减的方法就是遍历一遍数组元素看看是递增还是递减。A[i] &gt;= A[i - 1]; // 递增 A[i] &lt;= A[i - 1]; // 递减参考LeetCode Discuss：https://leetcode.com/problems/monotonic-array/discuss/165899/1-liner-C++ C++代码：123456789101112131415161718class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; A) &#123; int size = A.size(); if ( A[size - 1] &gt; A[0]) &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; if (A[i + 1] - A[i] &lt; 0) return false; &#125; return true; &#125; else &#123; for (int i = 0; i &lt; size - 1; ++i) &#123; if (A[i] - A[i + 1] &lt; 0) return false; &#125; return true; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share_Week5-制定项目规划]]></title>
    <url>%2F2018%2F10%2F10%2FArts%2FWeek5%2FArts-Share-Week5-MakeAPlan%2F</url>
    <content type="text"><![CDATA[最近在负责公司的一个项目，颇多感悟，一一记录一下。*项目情况 这是一个老的商用项目老项目一般都有一个共通的问题：维护成本很高。因为存活时间太久，经手太多人。如果没有一个统一的约定代码风格，可读性会很差。再加上项目只追求完成业务逻辑，不考虑或者不敢重构，因为怕影响现有逻辑，同时不考虑代码执行效率，只要项目可以跑，完成业务逻辑就可以。代码行间各种坏味道。 没有注释或者过多注释关键的函数注释太少，或者注释并没有随着项目代码的变更而更新。更常见的情况是，随处可见、层层叠叠的“BEGIN: add by xxx”,”END: add by xxx”, 极度影响代码的阅读和理解。不理解为啥有了git作为代码管理工具了，还需要写这么多谁修改的用意何在？！ 项目缺少文档或者文档过时文档对于项目开发来说很重要，让开发者知道需要把系统开发成什么样；让维护项目的工程师知道整个系统的业务和代码逻辑，便于结合源码深入理解整个系统。但是这个项目文档实在很随意，要么就是没有，缺少帮助新手快速理解系统并上手干活的资料。对于项目里涉及的一些软件和流程缺乏一个很系统的指导书，要么就是虽然有，但是很久没有更新，只能辩证的看… 项目的概要设计过于简略接手项目进行迭代开发时候适逢项目详细设计阶段。作为一个新人，我手上的概要设计的文档是由一个不懂代码的需求工程师完成的，对于业务逻辑的描述粒度不够，或者根本不涉及。详细设计阶段我需要参考其他模块的文档来理解负责模块的概要设计，然后在不理解业务和没有系统运行环境的情况下，光啃代码去完成详细设计。要命的是，需求工程师因为不懂代码，需求实际所需时间和预定时间差太多，代码量是预估的2倍，交付时间不变，期间还要参加公司的培训、完成一系列考核… 单元测试是为了应付指标达标项目也有单元测试，要满足行覆盖率80%以上。但是，项目紧、维护难、人手少，单元测试的指标最终也是应付了事。函数基本mock，并没有起到单元测试原先的作用。 项目的计划再三变更上面领导一声令下，下面的人就开始动起来垒代码。做了一半，领导拍了个脑袋说，这个方案不行啊。于是，代码开始回滚，从代码库里删除。之前几个月的努力泡汤。过几天，另一些领导开始拍大腿，不能白做了几个月，至少得要交付一个最小的子集模块，于是继续开始搬砖。紧接着，来了个更急的任务，所有编码工作暂停，所有人员转移到新任务去，因为之前那个任务很有可能不做或者要做，谁也不知道，但是现在手头新项目是权重最高的，那么，开始做吧。等着上面哪位领导继续拍脑袋或者大腿… 反思 根据敏捷开发的作法，越是这样老的系统，越需要在下一次的迭代开发的过程中重构优化，小步走，保证单元测试覆盖率，提升系统可维护性。 注释和文档一样重要，尤其是一些关键函数，如果过时的注释，还不如没有注释，否则只会误导后人。 文档的维护和更新要随着项目同时进行，并且需要有一个统一的地方去堆放相关的项目文档视频等资料，且需要有一个索引方便后人查找。 概要设计是后续详细设计的基础，如果前期做的不够好，后面就有可能出问题，导致详细设计中某些点考虑不全或者功能点遗漏。后期发现再来补救的成本就要高很多，得不偿失。项目开发交付周期的制定需要科学严谨，既满足客户的需求也要考虑实际情况，不是一拍脑袋就出结果。 单元测试和集成测试不是摆设和给上面交代的指标数据，如果做不到函数功能代码逻辑的覆盖，只能是形同虚设。 计划要科学，前期没有调研清楚就做做看的想法，只会浪费时间和金钱。制定一个计划同时也反映了一个领导的能力和远见，希望少拍几次脑袋和大腿，你不疼，我加班加的还疼呢…]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Share</tag>
        <tag>Week5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 905. Sort Array By Parity]]></title>
    <url>%2F2018%2F09%2F24%2FLeetCode%2FLeetCode-SortArrayByParity%2F</url>
    <content type="text"><![CDATA[题目描述：Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Example 1:123Input: [3,1,2,4]Output: [2,4,3,1]The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note:121 &lt;= A.length &lt;= 50000 &lt;= A[i] &lt;= 5000 题目大意：给定一个包含非负数整数的数组，返回一个数组，数组内包含所有的偶数，偶数后跟着A所有的奇数元素。 解题思路1：其实就是判断奇偶数，然后索引值对调。 C++代码：1234567891011121314class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; A) &#123; int size = A.size(); vector&lt;int&gt; v(size, 0); int startIdx = 0; int endIdx = size - 1; for (int idx = 0; idx &lt; size; idx++) &#123; if (A[idx] &amp; 1) v[endIdx--] = A[idx]; else v[startIdx++] = A[idx]; &#125; return v; &#125;&#125;; 解题思路2：相比第一种解法，思路2的方法差不多，时间复杂度O(n)，不同之处在于，思路2没有新增加空间，空间复杂度不变，原地操作元素。 参考LeetCode Discuss：https://leetcode.com/problems/sort-array-by-parity/discuss/170734/C++Java-In-Place-Swap C++代码：12345678class Solution &#123;public: vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt; A) &#123; for (int i = 0, j = 0; j &lt; A.size(); j++) if (A[j] % 2 == 0) swap(A[i++], A[j]); return A; &#125;&#125;; 数字奇偶性判定：1234数字num1. num % 2 == 0（偶数）； num % 2 != 0（奇数）2. num &amp; 1 == 0（偶数）； num &amp; 1 != 0（奇数）3. n &amp; (n-1) == 0 （偶数）； n &amp; (n-1) ！= 0 （奇数）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tip_Week4 - 文件的拷贝工具分享]]></title>
    <url>%2F2018%2F09%2F20%2FArts%2FWeek4%2FArts-Tip-Week4-CopyLargeFiles%2F</url>
    <content type="text"><![CDATA[原因 文件的拷贝复制大家都不陌生，但如果是10GB以上的文件呢？大文件拷贝了解一下嘛。有过经验的同学都知道过程岂止一个“慢”字了得。尤其是，万一中途出个啥岔子，重新来吧….. 解决途径 现在救星来了，听说过Beyond Compare可以用来比较文件的差异，但是你知道么，在比较文件夹下的文件差异的时候，Beyond Compare还可以做的更多，可以用它来拷贝和移动大量的文件，并且关键的一点是不会出现拷贝一半挂了，只能从头开始的尴尬情况，因为假如中途拷贝停止，你完全可以重新通过Beyond Compare比较下文件夹的差异，只拷贝缺失的那部分文件。当然，肯定还有其他方法和途径完成上述操作，欢迎大家来一起分享和讨论。 具体操作 打开Beyond Compare软件，选择文件夹比较会话，打开会话操作界面。单击“浏览文件夹”按钮选择需要比较的文件夹。对比文件夹之间的差异部分以不同颜色标注显示。 复制文件时保持相对文件夹结构复制文件时保持相对文件夹结构的意思是，确定所有选定的文件路径之间的最小差，并创建在目标文件夹中。当您在复制文件时，您可以自定义目标位置存档文件，如果归档文件不存在，Beyond Compare将会为您创建它。 复制文件时保持基点文件夹结构在复制文件时，如果您选择以保持基点文件夹结构的方法复制文件，那么目标文件夹将会创建完整路径。 复制文件时不保持文件夹结构选择“复制文件时不保持文件夹结构”的方式复制文件夹，可以忽略所有的路径信息，直接将所有选定的文件复制到目标文件夹中。 参考使用Beyond Compare如何生成文件比较报告Beyond Compare使用教程]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Tip</tag>
        <tag>Week4</tag>
        <tag>Beyond Compare</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share_Week4-学习的感悟]]></title>
    <url>%2F2018%2F09%2F20%2FArts%2FWeek4%2FArts-Share-Week4-GoForward%2F</url>
    <content type="text"><![CDATA[今天看到新的数据结构和算法的专栏出来后，大家纷纷讨论和订阅，群里的一番讨论之后，有感记下。 基础的算法和数据结构，在这世界上有不知多少本书，有不知多少专业的人讲，还有不知多少个动画演示，如果这些都无法让你学会，为什么一个收费的专栏能呢？我成长的时候，只有几本为数不多的书，翻译的又烂，还没电脑学，上网也不方便，找不到人讨论交流，也没学习小组，也没人告诉我方法，就死啃，看一遍不懂就看两遍，再不懂就先放下，过段时间再来……从没什么问题。好些东西就是这样，死磕磕到一定时候你就开窍 了。（不过我那时没今天这么干扰）。 不破不立，破而后立蛹如果想变成美丽的蝴蝶，就要脱离它那安全而又温暖的巢穴，虽然这样会有一定的痛苦，并且会脱离这个安适的环境，但是在一定意义上来说却是获得了新生。人在面对一个舒适安逸的环境时，总会渐渐地沉迷于其中流连忘返，那么他的成就也就只能仅限于此了，无法再进一步，最终只能断送在这个安逸的环境中。走出舒适区，迎接新的开始，只有这样才会成长，才能追上这个时代发展的脚步，不辜负这个信息化的时代。 黄沙百战穿金甲，不破楼兰终不还很多人开始学习一段时间后，因为学习太枯燥，耐不住寂寞，最终放弃，看看各大图书网站卖的最好的永远是入门书籍，就可以知道大多数人都停留在入门阶段就止步不前。在此引用耗叔专栏里的一段话：一定要坚持，要保持长时间学习，甚至终生学习的态度。一定要动手，不管例子多么简单，建议至少自己动手敲一遍看看是否理解力透的细枝末节。一定要学会思考，思考为什么要这样，而不是那样。还要举一反三地思考。不要乱买书，不要追新技术新名词，基础的东西经过很长积累，会在未来至少10年通用。回顾一下历史，看看历史时间线上技术的发展，你才能明白明天会是什么样的。 反思订阅耗叔的专栏开始是冲着大神的名头去的，哪不知，入坑很深，干活很多。反思自己之前的学习模式： 书买很多，看不完，囤着 书看很多，很杂，没有系统性 看书满足低级心理需求，实践不多，只看不练，提升缓慢 曾经也看过几本经典的，缺乏持续坚持下去的决心，最终放弃现在需要沉下心来，补补基础，万丈高楼平地起，坚持学习，持续学习，动手实践，加油～ 取法于上，得乎其中；取法其中，得乎其下！There are long roads ahead. I will explore all fronts in search of the destination.不讨论， 不实践，不思考，不归纳，看再多的书都没用。ARTS走起! 拓展阅读 Teach Yourself Programming in Ten Years中文版 程序员的谎谬之言还是至理名言？]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Share</tag>
        <tag>Week4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review_Week4 - 科学研究表明为什么晚起的人比早起的人更聪明和富于创造力]]></title>
    <url>%2F2018%2F09%2F20%2FArts%2FWeek4%2FArts-Review_Week4-EveningPeopleAreSmarter%2F</url>
    <content type="text"><![CDATA[Why Evening People Are Smarter and More Creative Than Morning People, According to ScienceBy Melissa Chu You know how people associate sleeping in with laziness?你知道人们是怎么把睡觉和懒惰联系在一起的吗？ I used to have a terrible habit of not going to bed until the early hours of the morning. Whether I was up all night doing work, studying, surfing the net, or reading articles, it always felt like there weren’t enough hours in the day.我以前有一个很坏的习惯，就是不上床睡觉，直到凌晨。不管我整晚都在做工作、学习、上网或阅读文章，总感觉一天中没有足够的时间。 Besides, I seemed to feel more awake at 2 a.m. than at 9 a.m. While most people had their lights out, there I was, wide awake at my computer.此外，我在凌晨2点时似乎比上午9点更清醒。当大多数人都把灯关掉的时候，我却在电脑前完全清醒。 Unfortunately, I would wake up the next day and realize that most of the morning had gone. Not to mention, people often associated my late rising habit with laziness.很不幸，当我我第二天醒来时，意识到大部分的早晨已经过去了。更不用说，人们总是把我的晚起的习惯和懒惰联系在一起。 If you’ve ever been in the same boat as me, there’s good news.如果你曾经和我有同样的遭遇，那就有好消息了。 People who sleep and wake up late tend to be smarter.Psychologist Satoshi Kanazawa set out to determine whether children’s sleeping habits correlated with intelligence. He recruited 20,745 adolescents from 80 high schools and 52 middle schools for his study.晚睡晚起的人往往更聪明一些。心理学家Satoshi Kanazawa开始着手研究儿童的睡眠习惯是否与智力有关。他从80所高中和52所中学招募了 20,745名青少年为他的研究工作。 The first meeting took place in their homes, where the students were asked to take an intelligence test. Five years later, he interviewed 15,197 of the original respondents again. This time, they reported when they went to bed and when they woke up on both the weekdays and weekends.第一次会议在他们的家里举行，学生们被要求进行智力测试。五年后，他又采访了15,197名原报名参与的志愿者。这一次，他们报告了他们上床睡觉的时间，包括他们在工作日和周末都醒来的时间。 He found that people with high intelligence are likelier to be night owls. This applied across a wide span of demographic variables, such as ethnicity, education, and religion. As Kanazawa explains it, sleeping late at night was rare back in our ancestors’ day, making it “evolutionarily novel.”他发现智商高的人更有可能成为夜猫子。这适用于广泛的人口统计学变量，如种族、教育和宗教。正如Kanazawa所说的那样，在我们的祖先的日子里，晚睡是很少见的，这使它成为“进化的小说”。 Evolutionarily novel — is a good thing, as his research suggests that intelligent people are more likely to adapt such behaviors.从进化的角度来看，这是一件好事，因为他的研究表明，聪明的人更有可能去适应这种行为。 How’s that for waking up late? But there’s more.起床晚又怎么样呢？接下来还有更多。 Night owls are mentally alert for a longer part of the day than early birds.People tend to think night owls are unproductive creatures since they sleep in while the early birds are already sitting at their desks. A 2009 study, however, shows that the opposite is true.夜猫子在思维敏捷的时间的保持上要比早起的鸟儿有更长的时间。人们倾向于认为夜猫子是一种没有效率的生物，因为他们睡觉的时候，早起的鸟儿已经坐在他们的办公桌前。然而，2009年的一项研究表明，事实恰恰相反。 Researchers at the University of Liege in Belgium monitored 15 extreme night owls and 16 extreme early birds in a lab. The volunteers had their brain activity measured an hour and a half after waking up, and again 10.5 hours after waking up.比利时Liege大学的研究人员在实验室里监测了15个极端的夜猫子和16个极端的早起鸟，这些志愿者在醒来后1.5小时后的大脑活动，醒来后10个小时的大脑活动。 In the morning test, the early birds and the night owls performed nearly the same in their responsiveness. But there was a gap 10.5 hours later: the night owls later showed faster reaction times and were more awake than the early birds.在早晨的测试中，早期的鸟类和夜猫子在反应能力上几乎是一样的。但10个小时后出现了一个差异：夜猫子们的反应时间比早起的鸟儿要快，而且比早起的鸟儿更清醒。 Appearances can be deceiving. While the early risers look like they’re hard at work throughout the day, the night owls seem to be more consistent overall in their productivity levels.外表可能是骗人的。虽然早起的人看起来一整天都在努力工作，但夜猫子们在他们的生产力水平上似乎更加一致。 Working late at night helps people find creative solutions.Researchers at the Catholic University of the Sacred Heart in Miami found that evening-oriented people are also more creative than their morning and intermediate counterparts.在深夜工作可以帮助人们找到创造性的解决方案。迈阿密圣心天主教大学的研究人员发现，即使是面向人的人也比他们的早起和介于中间的人更有创造力。 As Professor Marina Giampietro explains,正如Marina Giampietro教授所解释的那样， “[being in a nocturnal environment] may encourage the development of a non-conventional spirit and of the ability to find alternative and original solutions.”Not only are evening types smarter, but their unusual habits also help them to find creative solutions and alternatives. Non-conventional spirit, indeed. Who wouldn’t want to be a night owl?“在夜间活动环境中，可能会鼓励非传统精神的发展，以及寻找替代和原始解决方案的能力。”夜猫子们不仅更聪明，而且他们不同寻常的习惯也帮助他们找到创造性的解决方案和替代方案。非传统的精神,是的。谁不想当夜猫子？ Quick disclaimer about that last part, though. Whether you’re morning or evening-oriented is dictated by genetics, not by choice. As it turns out, a small group of brain cells is in charge of our internal clock and preferences for the time of day.不过，关于最后一部分的免责声明。无论你是早起还是晚起，都是由基因决定的，而不是由选择决定的。事实证明，一小群脑细胞负责我们的生物钟和一天中的时间偏好。 So, what’s the key takeaway from all this?那么，这一切的关键是什么呢？ Work according to your energy levels.As a night owl, it’s easy to feel pressured into working “normal” hours. That is, according to the standard workday of 9 am to 5 pm. But some of us aren’t built like that.根据你的精力水平工作。作为一个夜猫子，你很容易感到有压力在“正常”的工作时间。也就是每天早上9点到下午5点的标准工作日。但是我们中的一些人并不是这样的。 Some people work better at midnight, while others do their best work early in the morning. And, of course, there are those who lie somewhere in between.有些人在午夜工作得更好，而另一些人则在清晨做最好的工作。当然，也有一些人介于两者之间。 So if you tend to get your best ideas at a certain time of the day, take advantage of it and use that period to perform your most important tasks.因此，如果你倾向于在一天中的某一时刻得到最好的想法，利用它，利用这段时间来完成你最重要的任务。 You shouldn’t feel like you have to work or sleep according to a preconceived notion of working hours. If you freelance or work independently, this shouldn’t be too difficult to achieve. If you work in a full-time job, see if your boss is open to the idea of you working remotely from time to time.你不应该觉得你必须按照预先设想的工作时间来工作或睡觉。如果你是自由职业者或者独立工作者，这不难实现。如果你在一份全职工作中工作，看看你的老板是否对你时不时地远程工作的想法持开放态度。 The bottom line is: pay attention to your energy levels during the day and work with, rather than against it.底线是：关注你白天的精力水平，并与之合作，而不是对抗它。 The next time someone criticizes you for waking up late, remind that person that you’re not lazy, you’re evolutionarily progressive. Nighttime is for those who create, innovate and think out of the box.下次有人批评你起床晚了，提醒那个人你不是懒惰，而是进化的进步。夜晚是属于那些创造，创新和跳出思维定势思考的人。]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Review</tag>
        <tag>Week4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tip_Week3 - Code Diff工具分享]]></title>
    <url>%2F2018%2F09%2F09%2FArts%2FWeek3%2FArts-Tip-Week3-CodeDiffTool%2F</url>
    <content type="text"><![CDATA[Linux Linux下比较常用的代码比较工具是Meld。Meld 是一个可视化的文本差异比较工具，它可以跟多个版本控制系统集成。安装也极其便利：123sudo apt-get install updatesudo apt-get install meld 使用：绿色表示没有的，蓝色表示不同的。既然已经知道了不同之处，接下来就是合并了。看到蓝色和绿色颜色区域的“-&gt;”和“&lt;-”箭头没，只需点一下，即可。其他的一些例子和使用方法，可以参考： http://linux-commands-examples.com/meld 更多的一些Linux下的代码比较工具： https://www.fossmint.com/best-diff-merge-tools-for-linux/ Windows Windows下主要常用的是Beyond Compare，不过这个软件是付费的。但是相比同类产品还是比较便利。对于Windows下Git的用户来说，使用图形客户端进行差异比较和合并冲突比较直观，因此使用Beyond Compare作为git的比对与合并工具。 配置打开 C:\Users\Administrator.gitconfig 文件，添加如下内容12345678[diff] tool = bc4[difftool &quot;bc4&quot;] cmd = &quot;\&quot;c:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;[merge] tool = bc4[mergetool &quot;bc4&quot;] cmd = &quot;\&quot;c:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot; (其中bc4什么的根据你安装的/Beyond Compare版本来，以上举例是Beyond Compare4) 也可以通过命令行来设置，命令如下：12345678#difftool 配置git config --global diff.tool bc4git config --global difftool.bc4.cmd &quot;\&quot;c:/program files (x86)/beyond compare 4/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;#mergeftool 配置git config --global merge.tool bc4git config --global mergetool.bc4.cmd &quot;\&quot;c:/program files (x86)/beyond compare 4/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;git config --global mergetool.bc4.trustExitCode true 设置好后，使用命令是 git difftool 而不是之前的 git diff 了。 使用差异比较1git difftool &lt;filename&gt; 合并冲突1git mergetool 参考Windows下使用Beyond Compare作为git的比对与合并工具Git下的冲突解决git difftool说明文档浅析Beyond Compare复制文件的三种方式]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Tip</tag>
        <tag>Git</tag>
        <tag>Week3</tag>
        <tag>Beyond Compare</tag>
        <tag>Linux</tag>
        <tag>Windows</tag>
        <tag>Meld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review_Week3 - 如何像程序员一样思考 — 问题解决的课程]]></title>
    <url>%2F2018%2F09%2F07%2FArts%2FWeek3%2FArts-Review_Week3-HowToThinkLikeProgrammer%2F</url>
    <content type="text"><![CDATA[How to think like a programmer — lessons in problem solvingBy Richard Reis If you’re interested in programming, you may well have seen this quote before:如果你对编程感兴趣，你可能在此之前已经见过以下引用： “Everyone in this country should learn to program a computer, because it teaches you to think.” — Steve Jobs“在这个国家的每一个人都应该学习编程，因为它会教会你如何思考。” – 史蒂夫.乔布斯 You probably also wondered what does it mean, exactly, to think like a programmer? And how do you do it??你可能会想知道像一个程序员一样思考是什么意思？如何才能做到？ Essentially, it’s all about a more effective way for problem solving.实际上，这其实主要是关于如何解决问题的一种高效的方式。 In this post, my goal is to teach you that way.在这篇文章中，我的目的主要是教你们这个方法。 By the end of it, you’ll know exactly what steps to take to be a better problem-solver.到文章的末尾，你们将会知道采取什么步骤可以更高效解决一个问题。 Why is this important?为啥这个这么重要呢？ Problem solving is the meta-skill.解决问题是一种元认知技能。 We all have problems. Big and small. How we deal with them is sometimes, well…pretty random.我们都会遇到问题。大问题和小问题。有时我们如何处理这些问题都是随机的。 Unless you have a system, this is probably how you “solve” problems (which is what I did when I started coding):除非你有一个系统，也就是你如何解决问题（这也是我最初开始编程时候做的）： Try a solution.尝试一个方法。If that doesn’t work, try another one.如果它不能工作，换一个试试。If that doesn’t work, repeat step 2 until you luck out.如果还不行，重复步骤2直到你很幸运的找到解决方法。 Look, sometimes you luck out. But that is the worst way to solve problems! And it’s a huge, huge waste of time.看吧，有时候你还是很幸运的。但这是一种最差的解决问题的方法！并且，这种方法非常非常的浪费时间。 The best way involves a) having a framework and b) practicing it.最佳的方法应该是 a)有一个框架 b)不断练习。 “Almost all employers prioritize problem-solving skills first.“基本上所有的雇员都优先把解决问题的技能放在第一位。 Problem-solving skills are almost unanimously the most important qualification that employers look for….more than programming languages proficiency, debugging, and system design.解决问题的技能几乎是所有雇主寻找的最重要的特质，相比起程序语言的熟练，代码调试和系统设计来说。 Demonstrating computational thinking or the ability to break down large, complex problems is just as valuable (if not more so) than the baseline technical skills required for a job.” — Hacker Rank (2018 Developer Skills Report)“能被证实的计算能力或者是将一个大的复杂的问题拆分的能力相比起一份工作所需的基本技术技能要更有价值，或者更甚。”— Hacker Rank (2018 Developer Skills Report) Have a framework拥有一个框架To find the right framework, I followed the advice in Tim Ferriss’ book on learning, “The 4-Hour Chef”.找到一个合适的框架，我遵循 Tim Ferriss的书《The 4-Hour Chef》学习到。 It led me to interview two really impressive people: C. Jordan Ball (ranked 1st or 2nd out of 65,000+ users on Coderbyte), and V. Anton Spraul (author of the book “Think Like a Programmer: An Introduction to Creative Problem Solving”).它指引我面试了两个印象非常深刻的人：C. Jordan Ball（Coderbyte上65，000+的用户中排名数一数二）和 V. Anton Spraul（书《Think Like a Programmer: An Introduction to Creative Problem Solving》的作者）。 I asked them the same questions, and guess what? Their answers were pretty similar!我问了他们相同的问题，你猜怎么着？他们的答案非常相似！ Soon, you too will know them.很快你就会会知道了。 Sidenote: this doesn’t mean they did everything the same way. Everyone is different. You’ll be different. But if you start with principles we all agree are good, you’ll get a lot further a lot quicker.旁注： 这并不意味着他们都是按照同样的方式做事。每个人都不一样。你是独一无二的。但如果你一开始遵循我们认为好的原则，你将会收获更快的成长速度。 “The biggest mistake I see new programmers make is focusing on learning syntax instead of learning how to solve problems.” — V. Anton Spraul“我所见过的新手犯的最大的错误就是过于专注语法的学习，而不是去学习如何解决问题。” — V. Anton Spraul So, what should you do when you encounter a new problem?所以，当你面对一个新的问题的时候，你会怎么做呢？ Here are the steps:以下是一些步骤： Understand 理解Know exactly what is being asked. Most hard problems are hard because you don’t understand them (hence why this is the first step).搞清楚被问的是什么。大多数难题之所以困难是因为你并没有理解他们（因此，这为什么是第一步）。 How to know when you understand a problem? When you can explain it in plain English.如何知道你真正理解了一个问题? 当你可以用言简意赅的解释这个问题的时候。 Do you remember being stuck on a problem, you start explaining it, and you instantly see holes in the logic you didn’t see before?你还记得当年被一个问题困住的时候，你开始试图向别人解释它，突然你就注意到了你之前忽略的逻辑上的漏洞了？ Most programmers know this feeling.大多数程序员都有过这种感觉。 This is why you should write down your problem, doodle a diagram, or tell someone else about it (or thing… some people use a rubber duck).这也是为什么你应该写下你的问题，画一个草图或者尝试把问题讲解给别人听（或者别的招术，一些人用橡皮鸭替代）。 “If you can’t explain something in simple terms, you don’t understand it.” — Richard Feynman“如果你不能言简意赅地把问题解释给别人，你就还没有真正搞明白这个问题。” — Richard Feynman Plan 计划Don’t dive right into solving without a plan (and somehow hope you can muddle your way through). Plan your solution!不要在没有计划的情况下直接解决问题（如果不是，希望你可以蒙混过关）。请为你的解决方案制定计划。 Nothing can help you if you can’t write down the exact steps.谁也帮不了你，如果你不把具体的步骤写下来的话。 In programming, this means don’t start hacking straight away. Give your brain time to analyze the problem and process the information.在编程方面，这意味着不要马上开始黑客攻击。给你的大脑一些时间去分析这个问题，处理一些信息。 To get a good plan, answer this question:要制定一个好的计划，请回答这个问题： “Given input X, what are the steps necessary to return output Y?”“给定的输入 X, 什么是输出Y的必要的步骤?” Sidenote: Programmers have a great tool to help them with this… Comments!旁注： 程序员有一个非常好的工具帮助他们做到这点…注释！ Divide 分解Pay attention. This is the most important step of all.注意，这是最最重要的步骤。 Do not try to solve one big problem. You will cry.不要尝试一次解决一个很大的问题。你一定会哭的。 Instead, break it into sub-problems. These sub-problems are much easier to solve.相反，把它拆解成一些子问题。并且这些子问题要更容易解决。 Then, solve each sub-problem one by one. Begin with the simplest. Simplest means you know the answer (or are closer to that answer).然后，一次解决每一个子问题。从最简单的开始。最简单意味着你知道答案（或者接近答案）。 After that, simplest means this sub-problem being solved doesn’t depend on others being solved.除此之外，最简单意味着这个子问题不依赖其他问题的解决。 Once you solved every sub-problem, connect the dots.一旦你解决了所有子问题，把他们串起来。 Connecting all your “sub-solutions” will give you the solution to the original problem. Congratulations!把所有的”子问题的解”串起来后将得到原问题的解。恭喜你！ This technique is a cornerstone of problem-solving. Remember it (read this step again, if you must).这个方法是问题解决的转折。请千万要记住（如果有必要的话，请再读一遍步骤三）。 “If I could teach every beginning programmer one problem-solving skill, it would be the ‘reduce the problem technique.’“如果我要教给每一个刚踏入编程领域的新人一个解决问题的方法的话，那就是缩小问题规模的技术。For example, suppose you’re a new programmer and you’re asked to write a program that reads ten numbers and figures out which number is the third highest. For a brand-new programmer, that can be a tough assignment, even though it only requires basic programming syntax.比如，假设你是一个新手，你被要求写一个程序读取10个数字并找出第三大的数字。对于一个菜鸟来说，这是个难题，尽管它只需要基本的编程语法就可以做到。 If you’re stuck, you should reduce the problem to something simpler. Instead of the third-highest number, what about finding the highest overall? Still too tough? What about finding the largest of just three numbers? Or the larger of two?如果你被卡住了，你应该先把原问题拆分成简单的子问题。如果不是第三大的数字，而是找到所有数字中最大的一个？还会很难么？找到三个数字中最大一个呢？或者两个数字中最大的一个？ Reduce the problem to the point where you know how to solve it and write the solution. Then expand the problem slightly and rewrite the solution to match, and keep going until you are back where you started.” — V. Anton Spraul缩小问题的规模旨在你知道如何解决子问题并写出解。然后逐渐延伸扩展问题并重新解决，如此反复直到你回到最初的起点(解决了原始的问题)。” — V. Anton Spraul Stuck? 卡住了？By now, you’re probably sitting there thinking “Hey Richard… That’s cool and all, but what if I’m stuck and can’t even solve a sub-problem??”到目前为止，你可能会说： “我说Richard…这个方法并不酷，如果我被问题卡住了，甚至不能解决一个子问题咋办？” First off, take a deep breath. Second, that’s fair.首先，深呼吸。然后，当然可以搞定。 Don’t worry though, friend. This happens to everyone!不要慌，我的朋友。每个人都会遇到过此类情况。 The difference is the best programmers/problem-solvers are more curious about bugs/errors than irritated.不同之处在于最好的程序员/问题解决者显得更好奇，而不是恼怒。 In fact, here are three things to try when facing a whammy:实际上，当你遇到难题的时候，这三件事你可以试试： Debug: 调试Go step by step through your solution trying to find where you went wrong. Programmers call this debugging (in fact, this is all a debugger does).一步一步的调试你的解直到找到问题所在。程序员称之为debugging（实际上，这都是一个飞蛾给闹的）。 “The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”” — Andrew Singer“调试的艺术是搞清楚你真正告诉程序去执行的动作，而不是你想当然的事情。” — Andrew Singer Reassess: 回溯Take a step back. Look at the problem from another perspective. Is there anything that can be abstracted to a more general approach?退一步。从另一个角度来观察问题。有没有什么可以被抽象成更一般的方法？“Sometimes we get so lost in the details of a problem that we overlook general principles that would solve the problem at a more general level. […]“有时候我们会困在问题的细枝末节中，那是因为我们忽略了通用适用于各个级别的解决问题的原则” The classic example of this, of course, is the summation of a long list of consecutive integers, 1 + 2 + 3 + … + n, which a very young Gauss quickly recognized was simply n(n+1)/2, thus avoiding the effort of having to do the addition.” — C. Jordan Ball经典例子如下，求连续整数的和，1 + 2 + 3 + … + n, 年轻的高斯识别出是 n(n+1)/2, 避免了用于加法的额外运算。” — C. Jordan Ball Sidenote: Another way of reassessing is starting anew. Delete everything and begin again with fresh eyes. I’m serious. You’ll be dumbfounded at how effective this is.旁注：另一种重新评估的方法是重新开始。删除剩余的所有东西，我是认真的。 Research: 研究Ahh, good ol’ Google. You read that right. No matter what problem you have, someone has probably solved it. Find that person/ solution. In fact, do this even if you solved the problem! (You can learn a lot from other people’s solutions).啊，好啊，谷歌。你读的是对的。无论你的问题是啥呢么，别人早就解决了。找出那个人或者问题的解。实际上，即使你解决了这个问题，也要这样做！ Caveat:警告Don’t look for a solution to the big problem. Only look for solutions to sub-problems. Why? Because unless you struggle (even a little bit), you won’t learn anything. If you don’t learn anything, you wasted your time.不要花时间去找规模很大的问题的解。只寻找子问题的解。为啥呢？因为除非你挣扎（尽管可能一丁点儿），否则你不会学到任何东西，如果你不学习，那么就是在浪费时间。 Practice 练习Don’t expect to be great after just one week. If you want to be a good problem-solver, solve a lot of problems!不要期望在仅仅过了一个星期后就会很好。如果你想成为一个问题的解决者，你还需要解决很多问题！ Practice. Practice. Practice. It’ll only be a matter of time before you recognize that “this problem could easily be solved with.”练习，练习，再练习。在你发现“这个问题可以被快速的解决”前只是一个时间的问题。 How to practice? There are options out the wazoo!如何练习？有很多选择！ Chess puzzles, math problems, Sudoku, Go, Monopoly, video-games, cryptokitties, bla… bla… bla….国际象棋，数学问题，数独，围棋，强手游戏，电子游戏，以太猫等等。 In fact, a common pattern amongst successful people is their habit of practicing “micro problem-solving.” For example, Peter Thiel plays chess, and Elon Musk plays video-games.实际上，一个成功人士的通用的模式就是他们训练“解决微问题”。比如Peter Thiel 玩象棋， Elon Musk 打游戏。 “Byron Reeves said ‘If you want to see what business leadership may look like in three to five years, look at what’s happening in online games.’Byron Reeves说：“如果你想看看未来3到5年的商业领导力可能是什么样子，看看网络游戏中发生了什么吧。” Fast-forward to today. Elon [Musk], Reid [Hoffman], Mark Zuckerberg and many others say that games have been foundational to their success in building their companies.” — Mary Meeker (2017 internet trends report)回到今天。Elon Musk、Reid Hoffman、Mark Zuckerberg，还有其他人说过游戏是他们成功建立公司的基础。“ — Mary Meeker (2017 internet trends report)。Does this mean you should just play video-games? Not at all.这是不是意味着你要打游戏？并非如此。 But what are video-games all about? That’s right, problem-solving!但是什么是电子游戏呢？对了，解决问题！ So, what you should do is find an outlet to practice. Something that allows you to solve many micro-problems (ideally, something you enjoy).所以，你要做的就是找到一个练习的途径。可以能让你解决许多微问题（理想情况下，你喜欢的东西）。 For example, I enjoy coding challenges. Every day, I try to solve at least one challenge (usually on Coderbyte).比如，我喜欢程序挑战赛。每天我都要尝试解决至少一个挑战（通常在Coderbyte上）。 Like I said, all problems share similar patterns.正如我所说的，所有问题都有一个相似的模式。 Conclusion 总结That’s all folks!这些就是全部了！ Now, you know better what it means to “think like a programmer.”现在你对”像程序员一样思考“理解的更深刻一些了。 You also know that problem-solving is an incredible skill to cultivate (the meta-skill).你也知道解决问题是一种难以置信的技能（元技能）。 As if that wasn’t enough, notice how you also know what to do to practice your problem-solving skills!似乎这还不够，你也知道如何去实践解决问题的技巧！ Phew… Pretty cool right?恩，很酷对吧？ Finally, I wish you encounter many problems.最后，我祝愿你们面对很多问题。 You read that right. At least now you know how to solve them! (also, you’ll learn that with every solution, you improve).你阅读这个就对了。至少现在你知道如何解决问题（同时，你会发现在每一个解决方案中，你都会改进）。 “Just when you think you’ve successfully navigated one obstacle, another emerges. But that’s what keeps life interesting.就在你认为你已经成功地越过了一个障碍时，另一个又出现了。但这就是让生活变得有趣的原因。 Life is a process of breaking through these impediments — a series of fortified lines that we must break through.生活是一个突破这些障碍的过程——我们必须突破一系列的强化路线。 Each time, you’ll learn something.每一次你都会学到新东西。 Each time, you’ll develop strength, wisdom, and perspective.每一次，你都将发展力量、智慧和眼界。 Each time, a little more of the competition falls away. Until all that is left is you: the best version of you.” — Ryan Holiday (The Obstacle is the Way)每一次，更多的竞争就会消失。直到剩下的是你：最好的版本的你。”— Ryan Holiday (The Obstacle is the Way) Now, go solve some problems!现在去解决问题吧！ And best of luck祝你好运 Special thanks to C. Jordan Ball and V. Anton Spraul. All the good advice here came from them.特别感谢C. Jordan Ball 和 V. Anton Spraul。所有的好的建议都出自他俩。 Also, all the programming knowledge I’ve acquired in such a short time wouldn’t have happened without Lambda School. Can’t thank/ recommend them enough.同样，我在这么短的时间内获得的所有编程知识不会在没有Lambda School的情况下发生。不能感谢/推荐他们。]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Review</tag>
        <tag>Week3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share_Week3-如何高效的学习]]></title>
    <url>%2F2018%2F09%2F06%2FArts%2FWeek3%2FArts-Share-Week3-HowToStudy%2F</url>
    <content type="text"><![CDATA[“万丈高楼平地起，勿在浮沙筑高台.” ― 侯捷 背景第一次见到这句话，应该是四年前读《深入浅出MFC》的时候，不知道这是不是侯捷先生的原创。勿在浮沙筑高台。问题一：学习是件逆人性的事，现在的生活工作节奏很快，时间都是碎片的，很容易就给自己一个借口：“没时间，太累了，想放松一下…”诸如此类的借口可以找一大堆。说实话就是“懒”。问题二：书买了不少，也看了很多。大多数情况下，收效甚微。 答案这几天耗叔的专栏开始讲如何学习的主题，对此我也是很有兴趣。因为我想知道，在同样公平的时间下，为啥别人通过努力站在一个如今我只能仰望的角度。作为一个菜鸟，大神的学习和努力的过程总是充满神秘。这篇文章也算是对这个系列的总结吧。 问题一解答：在信息化的社会，像几十年前父辈一样，泡杯茶，端坐书桌前，摊开一本书细细品读个几个小时的生活已经一去不复返。现在生活工作节奏很快，如何利用好碎片时间提升自己，才可以在工作和生活中脱颖而出，至少比昨天的自己更进步一点。 问题二解答：学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。 学习的分类人的学习分为被动学习和主动学习两种。被动学习：如听讲、阅读、试听、演示，学习内容的平均留存率为5%、10%、20和30%。主动学习：如通过讨论、实践、教授给他人，会将原来被动学习的内容留存率从5%提升到50%、75%和90%。 人的记忆都是遵循艾宾浩斯遗忘曲线的，不过艾宾浩斯遗忘曲线对我们在实践学习中能起到的用处就是告诉我们以下2点:1、我们的知识的遗忘是由规律的2、遗忘的速度是先快后慢；观察曲线，你会发现,学得的知识在一天后，如不抓紧复习,就只剩下原来的25%。随着时间的推移,遗忘的速度减慢，遗忘的数量也就减少，得一个多月后就几乎忘得差不多了;而刚刚学习过的知识，记忆内容在80%-100%。这个遗忘规律告诉我们，要想让所学到的知识内容保持80%以上的长期记忆，只有不断地重复记忆，因为每复习一次就是记忆保持在刚刚学过的状态80%以上，多次强化后，短时记忆会形成长时记忆，就不会再忘记了。通过对知识内容的多次强化复习，记忆的内容会长期保持在80%以上。 如何才能正确高效地学习端正的学习态度和正确的学习观念学习不仅仅是为了找到答案，而是为了找到方法学习不仅仅是为了知道，而更是我饿了思考和理解学习不仅仅是为了开拓眼界，而更是为了找到自己的未知，为了了解自己学习不仅仅是为了成长，而更是为了改变自己，改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法 总结学习三个步骤 知识采集高质量的信息源是非常重要的，获取信息源头、破解表面新的内在本质、多方数据影子呢个，是这个步骤的关键。知识缝合所谓知识缝合就是把信息组织起来，成为结构体的知识。这里，连接记忆，逻辑推理，知识梳理是很重要的三部分。把知识炼成地图，将自己的理解反述出来。不断地反思和思辨，与不同年龄段的人讨论。技能转换通过举一反三、实践和练习，以及传授教导，把知识会转化成自己的技能。这种技能可以让你比进入更高的阶层。 拓展阅读 暗时间 如何高效学习:1年完成麻省理工4年33门课程的整体性学习法 把时间当作朋友 以下是文章相关链接：高效学习：端正学习态度高效学习：如何学习和阅读代码高效学习：深度，归纳和坚持实践]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Share</tag>
        <tag>Week3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 766. Toeplitz Matrix]]></title>
    <url>%2F2018%2F09%2F05%2FLeetCode%2FLeetCode-ToeplitzMatrix%2F</url>
    <content type="text"><![CDATA[题目描述：A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1:1234567891011Input:matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]Output: TrueExplanation:In the above grid, the diagonals are:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.In each diagonal all elements are the same, so the answer is True. Example 2:12345678Input:matrix = [ [1,2], [2,2]]Output: FalseExplanation:The diagonal &quot;[1, 2]&quot; has different elements. Note:1231. matrix will be a 2D array of integers.2. matrix will have a number of rows and columns in range [1, 20].3. matrix[i][j] will be integers in range [0, 99]. 题目大意：Toeplitz（托普利茨）矩阵是指各条从左上到右下对角线元素均相等的矩阵。给定M x N矩阵，判断是否为Toeplitz矩阵。 解题思路1： 遍历除了最后一行和最后一列的元素，查看每个元素对角线上的下一个元素是否相等。参考LeetCode Discuss：https://leetcode.com/problems/toeplitz-matrix/discuss/113417/Java-solution-4-liner. C++代码：1234567891011class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; for (int i = 0; i &lt; matrix.size() - 1; i++) &#123; for (int j = 0; j &lt; matrix[i].size() - 1; j++) &#123; if (matrix[i][j] != matrix[i + 1][j + 1]) return false; &#125; &#125; return true; &#125;&#125;; 解题思路2： 除了逐个遍历元素以外，观察可得，只需要考虑第一行和第一列的元素（除第一行最后一个元素和第一列最后一个元素以外）是否存在对角线上元素与之相等。 C++代码：12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int row = matrix.size(); int col = matrix[0].size(); for (int idx = 0; idx &lt; row - 1; idx++) &#123; int i = idx; int j = 0; while(i &lt; row &amp;&amp; j &lt; col) &#123; if (matrix[idx][0] != matrix[i][j]) &#123; return false; &#125; i++; j++; &#125; &#125; for (int idx = 0; idx &lt; col - 1; idx++) &#123; int i = 0; int j = idx; while(i &lt; row &amp;&amp; j &lt; col) &#123; if (matrix[0][idx] != matrix[i][j]) &#123; return false; &#125; i++; j++; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 867. Transpose Matrix]]></title>
    <url>%2F2018%2F08%2F30%2FLeetCode%2FLeetCode-TransposeMatrix%2F</url>
    <content type="text"><![CDATA[题目描述：Given a matrix A, return the transpose of A.The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix. Example 1:12Input: [[1,2,3],[4,5,6],[7,8,9]]Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2:12Input: [[1,2,3],[4,5,6]]Output: [[1,4],[2,5],[3,6]] Note:121 &lt;= A.length &lt;= 10001 &lt;= A[0].length &lt;= 1000 题目大意：把一个矩阵按照主对角线，翻转行列的数值。测试样例见题目描述 解题思路：其实就是讲远矩阵的行列颠倒过来，按主对角线翻转就是元素的行列索引值对调。 参考LeetCode Discuss：https://leetcode.com/problems/transpose-matrix/discuss/146797/C++JavaPython-Easy-Understood C++代码：123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; vector&lt;vector&lt;int&gt; &gt; vRes; if (0 == A.size()) return vRes; int row = A.size(); int col = A[0].size(); for (int colIdx = 0; colIdx &lt; col; colIdx++) &#123; vector&lt;int&gt; v; for (int rowIdx = 0; rowIdx &lt; row; rowIdx++) &#123; v.push_back(A[rowIdx][colIdx]); &#125; vRes.push_back(v); &#125; return vRes; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share_Week2-如何正确高效地问对问题]]></title>
    <url>%2F2018%2F08%2F30%2FArts%2FWeek2%2FArts-Share-Week2-HowToAskQuestions%2F</url>
    <content type="text"><![CDATA[“Judge a man by his questions rather than by his answers.” ― Voltaire 背景可能大家看到这个标题觉得很不以为然，不就是问问题么？谁不会啊！可你有想过高效正确的问对问题么？耗叔曾经写过一篇文章X-Y Problem。今天选择聊这个话题也是因为最近接手的项目周期比较赶，文档缺失，但是又需要你能快速把握整个系统，所以就需要跟很多与这个项目有关联的人打交道，这个就挺考验提问的技巧。言归正传，下面就开始谈谈怎么高效地问对问题。 为什么要问问题这个好像是废话，因为不懂，因为想知道为什么，好了下一个… 你想要的是什么当你在想要问问题前，你必须先要知道你到底想要问的是什么，并且把一个问题放到一个合适的上下文环境中，这样才有助于回答者可以快速理解你的问题点并给出回答。 如何才能正确高效地问对问题让我们先从一个例子开始： 你: “老板，我需要怎样做才能得到提升啊?”老板:“你必须按期完成我们需要的目标！”呵呵，这不是开玩笑。老板的回答的确回答了你的问题, 但是可能并不是你所期望的回答。你只能疑惑地离开，想着老板是不是对你的工作和进步不太在意? 让我们换另一种方法: 你: “老板, 假设我按期完成了目标，如果我想要得到提升，那么在其他方面我还需要做什么？”老板: “呃，你也确实应该涉及决策部门了，而不仅仅是完成任务。” 正如你看到的，你的措辞对你得到的答复影响很大。所以，聪明的问问题方法是：把对方会显而易见的回答变成自己的陈述包含在你问的问题中。让别人顺着你“设计好的圈套”回答你想知道的答案。这就是问问题的技巧。 问问题的场合不同的场合和形势下，你问问题所用的方法也会不同。不同场合需要换位思考，别人是否方便回答你的问题，比如以下几个场合就不是很方便： 在别人打电话的时候； —非常忙碌的时候； 正在休息的时候； 开会的时候； 会见客人的时候； 处理私人问题的时候； 当然首先语言上一定要注意礼貌问题，打招呼时先说你好。这样不会引起别人的反感。其次，且不说别人给出的答案是否100%正确，当别人花时间给你解释和回答了问题，结束时候记得要感谢别人，礼尚往来。 问可供选择的问题这个技巧其实是很多做销售的人惯用的技巧。不要问只有“是”与“否”两个答案的问题，除非你十分肯定答案是“是”。例如：不要问：“你想买双门轿车吗?”；要问：“你想要双门还是四门轿车?”如果你用后面这种二选一的问题，回答问题的人就无法拒绝你。 要问具体的内容不要问太泛的问题，因为这些问题的回答往往也是可有可无，你得不到有价值的答案。所以，尽量问你所关心的具体内容，有针对性的去问问题，每个问题最好都集中针对某个具体的点。同时，对于问题的描述一定要言简意赅，最简单概括的语言把你的问题说出来，让人家听懂，这样也给对方一个思考的时间。 学会聆听 Silence is golden.问问题是一个相互沟通的过程，成为一个好的听众也很重要。尤其是别人正在说话或者回答问题时候，贸然的打断显得很不礼貌，同时也可能打乱别人的逻辑。 换位思考问自己花一秒钟的时间思考一下你将如何回答你将要问的问题，换位思考，假如你是对方，你会怎么回答这个问题？ 这个问题的描述是否准备，措辞是否得当？ 如果不合适，请考虑换个措辞或者修改问题的描述。国外有个很著名的橡皮鸭子解决问题法, 大意就是提交问题的人应该在提问前多花点时间研究一下他们的问题，整理思路，对着一只橡皮鸭提出的问题。在提问的过程中思考，自己的问题是否是自己想要的问的东西？在这个过程中，说不定不用找别人提问，自己就有了答案。 确认是否听懂了回答如果问题很重要，你必须反复确认你是否听明白了回答，你可以用下面的办法确认你听到的回答： 重复“哦，你的意思是说如果X和Y发生的话，Z就会发生。对吗？” 装不懂：“好的，你可以稍微再解释一下吗（我只想确定我是否听明白了）？” 换做自己的话说：“嗯，不错。如果X和Y发生的话，我应该期望Z会发生，因为…”使用和回答者不同的措辞，并把你认为的话添加在后面。即使你所认为的事情可能并没有在会话中出现，但是，加上你说的话会使这场谈话更有价值。 训练在问别人前，先按照以下方法向自己发问，通过平时稍加训练，有助于你成为更好的思考者。 Focus: What specifically do I want to know? What information am I missing? Is this more than a simple YES or NO question? Am I going for deeper knowledge? Purpose: Why am I asking this? Do I want to gather facts or opinions? Do I need simple clarification? Do I want to offer a different perspective? Intent: How do I want people to respond? Do I want the answer to be of help to others? Am I asking to start an argument or open a discussion? Is the question superficial and not really useful or important? Am I asking out of frustration or curiosity? Do I really care about the answer? Am I willing to show respect/deference to the person I’m asking? Framing: Am I using easily understandable terms and wording? Is my question neutral or does it contain bias or opinion? Is it too long or too short? Does it contain the focus of what I want to know? Does the question focus on only one thing? Is it muddled with other inquiries that don’t belong? Follow-up: Do I have any more specific questions to add? Will the person I’m asking be available for other questions if need be? If I still don’t have the answer I need, what’s my plan? What can I do if I still don’t understand? 总结问问题也是一门艺术，其中有很多技巧，上面只是几个关键的点。在你下次问问题的时候，不妨换一个问法，相信你会有新的体验和收获。 以下是文章相关链接： https://www.douban.com/group/topic/8100581/ https://jingyan.baidu.com/article/fdbd4277a5d7e8b89f3f485a.html https://www.entrepreneur.com/article/254264 https://hbr.org/2009/05/real-leaders-ask.html https://www.lifehack.org/articles/communication/how-amazingly-good-asking-questions.html https://www.inc.com/rhett-power/great-leaders-ask-the-right-questions.html https://www.coachingforchange.com/pub10.html https://medium.com/personal-growth/are-you-asking-the-right-questions-48c7de027de https://globaldigitalcitizen.org/ask-good-questions-infographic]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Share</tag>
        <tag>Week2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tip_Week2 - 使用Hexo和GitHub搭建博客，出现hexo -d报错解决方案]]></title>
    <url>%2F2018%2F08%2F29%2FArts%2FWeek2%2FArts-Tip-Week2-HexoDeployGithub%2F</url>
    <content type="text"><![CDATA[一、背景 之前按照网上的教程，自己用Hexo搭建了一个博客。为了偷懒，写了一个hook的脚本，实现一行命令提交并且更新博客内容，见文稿:Hexo环境搭建个人博客。但是之前Hexo的部署方案有问题，隔了一段时间以后发现没办法提交Github和部署到自己的博客网站了。 二、解决方案 解决方法是修改根目录下的_config.yml配置下面是文档 中的写法12345deploy:type: gitrepo: &lt;repository url&gt;branch: [branch]message: [message] 修改为1234567deploy:- type: git repo: git@VPS的IP地址:/home/git/hexo.git#VPS上对应的git仓库(包含git hooks的地址) branch: master- type: git repo: git@github.com:&#123;yourname&#125;/hexo.git#github上对应的保存静态文件的仓库 branch: master 三、后记 以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。 https://www.zhihu.com/question/38219432]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Hexo</tag>
        <tag>Tip</tag>
        <tag>Git</tag>
        <tag>Week2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review_Week2 - Remote Code Execution on a Facebook server]]></title>
    <url>%2F2018%2F08%2F25%2FArts%2FWeek2%2FArts-Review_Week2-RemoteCodeExecution%2F</url>
    <content type="text"><![CDATA[Remote Code Execution on a Facebook serverBy Blaklis I regularly search for vulnerabilities on big services that allow it and have a Bug Bounty program. Here is my first paper which covers a vulnerability I discovered on one of Facebook’s servers.我经常在大型服务器中需找漏洞，并且有个bug赏金计划。这个是我的第一篇文章，其中介绍了一个我在一台Facebook的服务器上发现的漏洞。 While scanning an IP range that belongs to Facebook (199.201.65.0/24), I found a Sentry service hosted on 199.201.65.36, with the hostname sentryagreements.thefacebook.com. Sentry is a log collection web application, written in Python with the Django framework.当我在扫描属于Facebook（199.201.65.0/24）的IP范围时，我在199.201.65.36中找到了一个岗哨服务，主机名叫sentryagreements.thefacebook.com。岗哨是一个日子收集的网络程序，基于Django framework使用python开发的。 While I was looking at the application, some stacktraces regularly popped on the page, for an unknown reason. The application seemed to be unstable regarding the user password reset feature, which occasionally crashed. Django debug mode was not turned off, which consequently prints the whole environment when a stacktrace occurs. However, Django snips critical information (passwords, secrets, key…) in those stacktraces, therefore avoiding a massive information leakage.正当我在看这个应用的时候，不知道什么原因，一些stacktraces不时的在页面上弹出。关于用户密码重置这个特性来看，这个应用看起来很不稳定，不时的崩溃。Django debug mode并没有关闭， 结果是当stacktrace发生时，日志打印出整个环境信息。无论如何，Django抓取了一些诸如密码和秘密，还有密钥等的关键的信息 However, by looking at the stacktrace a little more closely, some env keys were interesting :无论如何，稍微仔细看了下stacktrace，一些环境的key值非常有意思：12345678The SESSION_COOKIE_NAME is sentrysidSESSION_COOKIE_NAME是岗哨服务The SESSION_SERIALIZER is django.contrib.sessions.serializers.PickleSerializerSESSION_SERIALIZER是django.contrib.sessions.serializers.PickleSerializerThe SESSION_ENGINE is django.contrib.sessions.backends.signed_cookiesSESSION_ENGINE是django.contrib.sessions.backends.signed_cookiesThe SENTRY_OPTIONS key that contains some Sentry configuration in a list.SENTRY_OPTIONS键值包含了一些岗哨的在一个列表中的配置信息。 Pickle is a binary protocol for (un)serializing Python object structures, such as classes and methods in them. A comprehensive article that explains what Pickle is and its security implications is available here :https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/Pickle是一个用于python对象数据结构序列化和反序列化的协议，比如其中的类和方法。一篇关于Pickle和它的安全实现的文章地址如下：https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/ If we were able to forge our own session that contains arbitrary pickle content, we could execute commands on the system. However, the SECRET_KEY that is used by Django for signing session cookies is not available in the stacktrace. However, the SENTRY_OPTIONS list contains a key named system.secret-key, that is not snipped. Quoting the Sentry documentation, system.secret-key is “a secret key used for session signing. If this becomes compromised it’s important to regenerate it as otherwise its much easier to hijack user sessions.“; wow, it looks like it’s a sort of Django SECRET-KEY override!如果我们可以在我们的session里包含一些任意的pickle的内容，我们就可以执行系统的命令。无论如何，stacktrace里的被Django用于单独签名的session cookiesSECRET_KEY是无效的的。无论如何，SENTRY_OPTIONS的键值里包含system.secret-key，这是逃不掉的。引用Sentry的文档，system.secret-key是用于session 签名的一个的密钥。如果这一问题被破坏，那么重新生成它是很重要的，否则就更容易劫持用户会话。wow, 这看起来就像 Django 的某个SECRET-KEY被覆写了。 As we have everything to forge our own cookies with arbitrary pickle content, I wrote a little script that adds a payload into my own sentrysid cookie. Here it is :我们想把一切东西都融合到我们包含arbitrary pickle的cookies里，我写了一个小脚本用于添加负载到我的sentrysid cookie里。如下所示：12345678910111213141516#!/usr/bin/pythonimport django.core.signing, django.contrib.sessions.serializersfrom django.http import HttpResponseimport cPickleimport osSECRET_KEY=&apos;[RETRIEVEDKEY]&apos;#Initial cookie I had on sentry when trying to reset a passwordcookie=&apos;gAJ9cQFYCgAAAHRlc3Rjb29raWVxAlgGAAAAd29ya2VkcQNzLg:1fjsBy:FdZ8oz3sQBnx2TPyncNt0LoyiAw&apos;newContent = django.core.signing.loads(cookie,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=&apos;django.contrib.sessions.backends.signed_cookies&apos;)class PickleRce(object): def __reduce__(self): return (os.system,(&quot;sleep 30&quot;,))newContent[&apos;testcookie&apos;] = PickleRce()print django.core.signing.dumps(newContent,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=&apos;django.contrib.sessions.backends.signed_cookies&apos;,compress=True) This code is a simple proof of concept; it takes the content of an existing sentrysid cookie, and replaces its content with an arbitrary object that will run a os.system(“sleep 30”) when unserialized.这个代码是对概念的简单的证实。它获取了现存的sentrysid的cookie的内容，然后一个任意的对象替换了其中的内容，当反序列化的时候就会执行os.system(“sleep 30”)。 When using this cookie, the page actually takes an additional 30 seconds to load, which confirms the presence of the flaw.当使用这个cookie的时候，页面就会自然等待30秒的去加载，以上证实了缺陷的存在。 Facebook acknowledged the vulnerability, took down the system until the flaw was patched, and then notified me about the patch being in place.Facebook知道了这个漏洞，关闭了系统直到缺陷被打上补丁。然后通知我补丁已经就位。 Here is the disclosure timeline, which also demonstrates that Facebook security staff is reactive:下面是批露的一些时间线，更证实了Facebook安全人员是被动的。1234567830.07.2018 00:00 CEST : initial disclosure with every details.30.07.2018 00:00 CEST : 初始化泄漏所有的细节.30.07.2018 15:25 CEST : triaged and system takedown.30.07.2018 15:25 CEST : 系统修复和可拆卸.09.08.2018 18:10 CEST : patch in place.09.08.2018 18:10 CEST : 补丁就位.09.08.2018 20:10 CEST : a 5000$ bounty is awarded – the server was in a separate VLAN with no users’ specific data.09.08.2018 20:10 CEST : 一个5000美元的赏金被授予——服务器位于一个单独的VLAN中，没有用户的特定数据. Thanks for reading!]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Review</tag>
        <tag>Week2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Share_Week1-不做伪工作者]]></title>
    <url>%2F2018%2F08%2F21%2FArts%2FWeek1%2FArts-Share-Week1-HowToWork%2F</url>
    <content type="text"><![CDATA[今天听了《吴军硅谷来信-001封信|不做伪工作者》，感触颇多，稍微整理记录一下，分享出来。 伪工作者的定义伪工作者（Pseudo Worker），来源于Google。指代一些每天应付事务性的工作的人。这些人虽然每天把自己搞得很忙，但是他们所作的工作（也被称为伪工作）并不会对公司的发展产生什么重大效果，俗称碌碌无为。 产生条件 当员工对自己在公司的境遇不满，他们会消极对待工作，不自觉成为一个伪工作者。 一些员工总是挑些简单的事情而不是有挑战的工作去做，工作状态看上去饱和，但是实际上是在坑自己，伪工作做的越多，个人进步就越慢，甚至倒退。 解决方法对于管理者 管理者要让员工站在“做什么事情能让公司最大收益”的基础上去工作。只有这样才能让员工开始动脑筋在做不完的工作中找到那些对公司最有帮助的时期去做，而不是就简单应付老板安排的工作并交差。 管理者要让员工明白，他们积极工作（而不是消极完成任务），最大的受益方是他们自己。 对于员工自身一个人追求的不是完成了百分之几，或者百分之几十的工作，而是做完了那几件重要的事情。一个聪明的员工，应该善于找到最重要的工作，并且优先完成它们，产生最大化收益。而这个，恰恰是每一个新员工说欠缺的。 宽泛的讲，其实很多人在生活中，也是不断把时间浪费在那些可做可不做的事情上，然后收效甚微。 反思工作很多，永远也不可能做不完。这叫要求我们要会甄别什么才是最重要的工作，可以借鉴80-20法则，往往20%的工作才是最有产出的工作，也最应该我们花时间花精力把它做好，只有这样才能称得上Smart Work。当然，找对做事情的方法后，还要做好对时间的把控。不然只是在做重复性的劳动，这样的情况，在优胜劣汰的自然界，是迟早要被淘汰的。 吴军的观点：在面对总也做不完的工作，主动的站在对公司业务帮助最大的角度，站在提升自己能力的角度，把那些最重要的完成了。 罗胖的观点：面对那些可做可不做的事情，只要有时间就去做。 愿你在工作之余还能有时间欣赏身边的风景。 以下是文章相关链接： https://www.jianshu.com/p/ba5371bc53b7 https://www.jianshu.com/p/3a33de2675f9]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Week1</tag>
        <tag>Share</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tip_Week1 - Git 换行符（LF和CRLF）问题解决]]></title>
    <url>%2F2018%2F08%2F20%2FArts%2FWeek1%2FArts-Tip_Week1-GitLineEndingCharacter%2F</url>
    <content type="text"><![CDATA[一、背景 在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF）作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。 二、解决方案 Git设置12git config --global core.autocrlf falsegit config --global core.safecrlf true AutoCRLF提交时转换为LF，检出时转换为CRLFgit config --global core.autocrlf true 提交时转换为LF，检出时不转换git config --global core.autocrlf input 提交检出均不转换git config --global core.autocrlf false SafeCRLF拒绝提交包含混合换行符的文件git config --global core.safecrlf true 允许提交包含混合换行符的文件git config --global core.safecrlf false 提交包含混合换行符的文件时给出警告git config --global core.safecrlf warn IDE设置使用UNIX换行符IDEA的设置File -&gt; SettingsEditor -&gt; Code StyleLine separator (for new lines) ，选择：Unix and OS X (\n) 对已使用Windows换行符的文件，可以使用Sublime Text打开，View-&gt;Line Endings，选Unix，保存； 三、后记 以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。 https://www.cnblogs.com/zjoch/p/5400251.html https://blog.csdn.net/w6248117/article/details/76177103 https://blog.csdn.net/guodengh/article/details/8630888 http://kuanghy.github.io/2017/03/19/git-lf-or-crlf]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Week1</tag>
        <tag>Tip</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Review_Week1 - What Was Elon Musk Thinking?]]></title>
    <url>%2F2018%2F08%2F20%2FArts%2FWeek1%2FArts-Review_Week1-ElonMuskThinking%2F</url>
    <content type="text"><![CDATA[What Was Elon Musk Thinking?By James B. Stewart There’s no question that Elon Musk is one of the great entrepreneurs of this era. He may even be in “a class of one,” as he recently described Tesla, the revolutionary electric car company he founded.毫无疑问，埃隆·马斯克是这个时代最伟大的企业家之一。他甚至也可能是那一类人，他最近提及他创立的革命性的电动汽车公司特斯拉。 But Musk’s tweet last week — expressing his intent to take Tesla private and declaring that he had “funding secured” for the multibillion-dollar transaction — was so impulsive, potentially inaccurate, poorly worded and thought out, and with such potentially dire consequences for himself, Tesla and its shareholders, that the board now must ask a sensitive but vital question: What was Musk’s state of mind when he wrote it?但就在马斯克上周在推特上发文透露他有意将特斯拉私有化，并且声称他有足够的资金担保。推文如此冲动、可能并不准确，措辞不当并且欠缺考虑，对他自己造成了潜在的可怕的后果。特斯拉的股东还有董事此刻一定想问一个敏感但是至关重要的问题：“马斯克在写这些话的时候脑子里到底在想啥？” “What does this say about the judgment of the person who set all this in motion?” said Charles M. Elson, director of the Weinberg Center for Corporate Governance at the University of Delaware. “That’s what the board has to find out.”“这些所作所为到底说明了什么？”， 特拉华州大学的温伯格公司管理中心的主管Charles M. Elson这么说道，“这也正是董事会想要知道的。” Musk, in subsequent blog posts, has stressed that he was only trying to be as transparent with the public as he was about to be with a few major investors.马斯克在后续的博客推文中强调他只是想要在和几个主要投资人在一起的时候在公众前变得透明。 That is a laudable goal. But there are plenty of effective, conventional methods for achieving them, which include keeping his board fully informed, consulting lawyers, and following Securities and Exchange Commission procedures before tweeting about what could be a transformative, hugely expensive corporate buyout.这是一个值得赞赏的目标。但在推特上发文要做出一个颠覆性、非常昂贵的公司收购意向前，依然有很多有效并且传统的途径可以达到这些目的，比如在与董事会充分沟通、咨询律师，并且遵循证券交易委员会的程序。 Little if any of this appears to have happened. While Tesla directors have said they discussed with Musk the possibility of taking Tesla private in general terms, they were blindsided by the tweet and have been scrambling ever since to get the situation under control.假如这一切都发生了。特斯拉的主管声称他们已经和马斯克关于将特斯拉私有化的一般条款进行过磋商，他们还是被这条推文弄得措手不及，从那以后就一直在手忙脚乱地控制局面。 The explanation for the tweet may be more psychological than strategic. In a Twitter exchange from last summer, Musk said he experienced “great highs, terrible lows and unrelenting stress.”推特的文字的意义可能心理作用大于战略作用。在去年夏天一次交流中，马斯克曾经表示他体会过巨大的高潮，可怕的低谷和无情的压力。 Asked if he might be bipolar, he replied, “Yeah.” Then he added, “Maybe not medically tho. Dunno. Bad feelings correlate to bad events, so maybe real problem is getting carried away in what I sign up for,” which he later described as a “ticket to hell.”当被问及他是否患有躁郁症时候，马斯克回应，“是的”。然后他补充道：“也许不是医学上认定的那样。坏的情绪总是和坏的事情有关联，所以也许真正的问题是被我所签的东西冲昏了头脑”。他后来描述为“一张通往地狱的车票”。 “Entrepreneurs often have a temperament and a constellation of traits that can create enormous value but are also associated with significant risks,” said Michael A. Freeman, a clinical professor of psychiatry at the University of California, San Francisco, whose research and practice focuses on entrepreneurs.“企业家总是有一些喜怒无常和一个星座的特质，这些东西可以创造巨大的价值，但是也伴随着巨大的危险”。旧金山加州大学的精神病学临床教授Michael A. Freeman如此说道。他的研究的对象是一些企业家。 While Freeman said he couldn’t comment on Musk, whom he’s never treated, he said that his research and experience with clients show that entrepreneurs generally “have mental health profiles that are associated with higher levels of creativity, higher levels of energy, higher levels of risk tolerance and higher levels of impulsivity. Another way to look at impulsivity is a need for speed, a sense of urgency, higher motivation, and greater restlessness.”但是Freeman说他不能对马斯克做出任何评价，因为他从未诊治过他。他研究经历显示通常患有精神病症的企业家都拥有更高水平的创造力、精力、风险承受能力和、冲动。另一种看待冲动的方式是对速度的需要，一种紧迫感，更高的动力，和更大的不安。 All of that would seem consistent with Musk’s Twitter habits.所有这些似乎都与马斯克的Twitter习惯相一致。 Scott Shane, a professor of entrepreneurial studies at Case Western Reserve University, put it more simply: “These people are just wired differently,” he said. “They’re quicker to spot and act on opportunities, but that same tendency can get them into trouble in other situations.”凯斯西储大学的创业研究教授Scott Shane说的更简单：“这些人只是精力不一样，他们会更快地发现并采取行动，但同样的趋势会让他们在其他情况下陷入麻烦。” These qualities may also be exacerbated by lack of sleep. Musk has said he’s been sleeping on the factory floor, skipping showers, and working extremely long hours while Tesla ramps up production of its Model 3.这些品质可能因为缺乏睡眠而加重。马斯卡曾提及在特斯拉增加Model 3的产量期间，他睡在工厂的地板上，没时间洗澡，长时间的工作。 “There are a number of behavioral destabilizers in the world of entrepreneurship,” Freeman said, “and sleep deficiency is high on the list. The consequences can be impaired functioning, higher irritability, and judgment can be adversely affected.”“在创业的世界里有很多行为不稳定的人”, Freeman 说道，“睡眠不足很常见。直接导致的后果是身体功能受损、易怒、判断可能受到不利影响。” During Tesla’s most recent earnings conference call, Musk apologized to Wall Street analysts he had insulted during a previous call for asking “boring, bonehead questions.”在特斯拉最近的财报会议上，马斯克为自己在上一次财报会上的无礼向华尔街分析家道歉，他当时侮辱了“无聊的、愚蠢的问题”。 “There are reasons for it. I’ve gotten no sleep and been working sort of 110-hour, 120-hour weeks,” he said.“对此我有足够的理由。我没时间睡觉，并且一周连续工作110-120小时”，他解释道。 It’s also a common trait of entrepreneurs that they feel rules don’t apply to them. From their perspective, many rules “get in the way of getting things done,” Freeman said.创业者普遍有一个特质，他们认为规则并不适用。“从他们的角度来说，一些规则总是阻碍把事情搞定。” Freeman说道。 Whatever the exact circumstances of his tweet, Musk would benefit from what Freeman calls “personal boards of directors,” something he often recommends for his entrepreneurial clients. “There are some simple strategies for dealing with impulsivity, like sleep on something overnight and get a second opinion,” he said. “If you’re hard-wired to go full speed ahead at all times, you need to create a filter for yourself to decrease those risk factors.”不管他的推文的具体情况如何，马斯克将会从Freeman所说的“个人董事会”中受益。有些东西他总是推荐给他的企业客户，“有一些简单的方法用于处理冲动，比如睡一觉之后得到第二种想法”，马斯克说道，“如果你在任何时候都要全速前进，你需要为自己创建一个过滤器来减少这些风险因素”。 Tesla’s board should play an important role. “Balancing corporate responsibilities, and the constraints they can impose, against the creativity that made the corporation great in the first place is much more of an art than a science,” said Charles Whitehead, who leads the law, technology and entrepreneurship program at Cornell Law School. “Directors and lawyers need to credibly manage that balance, but as importantly, founders need to be willing to consult with them, recognizing that the advice — even if it slows things down — may simply reflect the realities of the day.”特斯拉的董事会需要扮演一个重要的角色，“相对创造力使得企业领先来说，平衡企业责任，以及他们可以施加的约束更像是一门艺术而非科学”，在康奈尔法学院领导法律、技术和创业项目的Charles Whitehead说道。“董事和律师需要可靠地管理这种平衡， 但更重要的是，创始人意向去和他们咨询、认可简单地反映当今的现实的建议， 尽管它们可能会减缓事情发展的速度”。 Freeman agreed. The Tesla board and others close to Musk “need to find ways to make all the positive aspects of those strengths work for him and for us while minimizing the downside.”Freeman提出，“特斯拉的董事会和其他与马斯克关系密切的人应当找到合适的方法让所有这些优势的工作成为积极方面的同时尽量减少不利方面。” And Musk may want to curb his use of Twitter. “One good rule of thumb: never make important, and in Tesla’s case, complex announcements through Twitter,” Whitehead said.“马斯克可能想要限制他对Twitter的使用的一个好的原则就是：绝不通过twitter上做出想特斯拉案例中的重要和复杂的通告”，Whitehead说道。 That may be easier said than done. Tesla’s board members have been urging Musk to stop tweeting, so far without success.这可能是说比做容易。特斯拉的董事会成员一直在敦促马斯克停止推特，到目前为止还没有成功。 “It’s not easy for anyone to control the behavior of a grand visionary,” Shane said. “These people don’t like to be controlled.”Shane说道：“要控制一个伟大的梦想家的行为并非易事。这些人从来不喜欢被控制”。]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Review</tag>
        <tag>Week1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 832. Flipping an Image]]></title>
    <url>%2F2018%2F08%2F19%2FLeetCode%2FLeetCode-FlippingAnImage%2F</url>
    <content type="text"><![CDATA[题目描述：Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1:1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2:1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Note: 121 &lt;= A.length = A[0].length &lt;= 200 &lt;= A[i][j] &lt;= 1 题目大意：根据给出的例子可以发现规则：翻转图像矩阵的每一行，并且对每一个元素取反 解题思路： 这道题总共要做2件事： 1. 数组中的每个单元逆序 2. 数组中的每个单元内的元素求反 参考LeetCode Discuss：https://leetcode.com/problems/flipping-an-image/discuss/130590/C++JavaPython-Reverse-and-Toggle C++代码：123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; vector&lt;vector&lt;int&gt; &gt; vRes = A; if (0 == vRes.size()) return vRes; for (int idx = 0; idx &lt; vRes.size(); idx++) &#123; vector&lt;int&gt;&amp; v = vRes[idx]; reverse(v.begin(), v.end()); vector&lt;int&gt;::iterator it = v.begin(); for (; it != v.end(); it++) &#123; *it = *it ^ 1; &#125; &#125; return vRes; &#125;&#125;; 代码分析：此题元素求反可以考虑（数组内的元素非0即1）： 1. 元素本身异或 2. 元素本身求反 3. 代码本身判断]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS - 左耳听风群的每周必做]]></title>
    <url>%2F2018%2F08%2F14%2FArts%2FMyArtsPlan%2F</url>
    <content type="text"><![CDATA[Algorithm每周至少做一个leetcode算法题 week1: 832.Flipping an Image week2: 867. Transpose Matrix week3: 766. Toeplitz Matrix week4: 905. Sort Array By Parity week5: 896. Monotonic Array Review每周阅读至少一篇英文技术文章 week1: 马斯克在想什么？ week2: 在Facebook服务器上执行远程代码执行 week3: 如何像程序员一样思考 week4: 科学研究表明为什么晚起的人比早起的人更聪明和富于创造力 Tip每周学习至少一个技术技巧, 最好是实际工作学到的 week1: Git换行符LF与CRLF转换问题 week2: 使用Hexo和GitHub搭建博客，出现hexo -d报错解决方案 week3: Code Diff工具分享 week4: 文件的拷贝工具分享 Share每周分享一篇有观点和思考的技术文章 week1: 不做伪工作者 week2: 如何正确高效地问对问题 week3: 如何高效的学习 week4: 学习的感悟 week5: 制定项目规划]]></content>
      <categories>
        <category>Arts</category>
      </categories>
      <tags>
        <tag>Arts</tag>
        <tag>Blog</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 717. 1-bit and 2-bit Characters]]></title>
    <url>%2F2017%2F12%2F01%2FLeetCode%2FLeetCode-1-bitand2-bitCharacters%2F</url>
    <content type="text"><![CDATA[题目描述：We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1:123456Input:bits = [1, 0, 0]Output: TrueExplanation:The only way to decode it is two-bit character and one-bit character. So the last characteris one-bit character. Example 2:123456Input:bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last characteris NOT one-bit character. Note: 121 &lt;= len(bits) &lt;= 1000.bits[i] is always 0 or 1. 题目大意：01序列由三种成分构成：10, 11, 0求序列经过解析后，最后一个成分是否为0 解题思路： 这道题就是已知一个字符串（最后一个字符0）和三种构成成分，判定该字符串是否合法。观察三种字符串可以发现，两bits的只有10和11两种（第一个bit都是1，第二bit随意），一个bit的只有0满足。转变思路后就是检查一个最后一个bit是0的字符串中是否存在单个bit是1的情况（00可以解析为2个bit的0组成）。 参考LeetCode Discuss：https://discuss.leetcode.com/topic/108743/java-solution-1-or-2/4 C++代码：12345678class Solution &#123;public: bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) &#123; int n = bits.size(), i = 0; while (i &lt; n-1) i += bits[i]+1; return i == n-1; &#125;&#125;; 代码分析：此题没有运用一个通用的算法，而是根据题目的特性做出解答，具体步骤就是 1. 放置一个指针在字符串首位用于遍历 2. 每次看见0的时候，往前走1步 3. 每次看见1的时候（可以认为是发现11或者10），往前走2步 4. 假如出现单个1的时候，指针往前走2步就可能超过字符串的本身长度，这种情况就是不符合题意的case。 正常遍历是可以最终到达n-1的位置（n为字符串长度）]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 169. Majority Element II]]></title>
    <url>%2F2017%2F11%2F28%2FLeetCode%2FLeetCode-MajorityElementII%2F</url>
    <content type="text"><![CDATA[题目描述：Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.Hint:How many majority elements could it possibly have? 题目大意：给定一个大小为n的整数数组，从中找出所有出现次数超过 ⌊ n/3 ⌋ 的元素。算法应该满足线性时间复杂度和O(1)空间复杂度。提示：一共可能有多少个“众数”？ 解题思路： 可以从Moore’s voting algorithm中得到一些启发 参考LeetCode Discuss：https://leetcode.com/discuss/43248/boyer-moore-majority-vote-algorithm-and-my-elaboration 观察可知，数组中至多可能会有2个出现次数超过 ⌊ n/3 ⌋ 的众数记变量n1, n2为候选众数； c1, c2为它们对应的出现次数遍历数组，记当前数字为num若num与n1或n2相同，则将其对应的出现次数加1否则，若c1或c2为0，则将其置为1，对应的候选众数置为num否则，将c1与c2分别减1最后，再统计一次候选众数在数组中出现的次数，若满足要求，则返回之。 C++代码：1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; majorList; // first round to find the candidates int count1 = 0; int candidate1 = 0; int count2 = 0; int candidate2 = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; // every iteration deal with one possibility if (candidate1 == nums[i]) count1++; else if (candidate2 == nums[i]) count2++; else if (0 == count1) &#123; count1 = 1; candidate1 = nums[i]; &#125; else if (0 == count2) &#123; count2 = 1; candidate2 = nums[i]; &#125; else &#123; count1--; count2--; &#125; &#125; // second round to check // notice that num1 and num2 can be the same, but in the following we only count once! count1 = count2 = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] == candidate1) count1++; else if (nums[i] == candidate2) count2++; &#125; if (nums.size()/3 &lt; count1) majorList.push_back(candidate1); if (nums.size()/3 &lt; count2) majorList.push_back(candidate2); return majorList; &#125;&#125;; 代码分析：此题是LeetCode 169. Majority Element的加强版，同时要找出大于n/3的众数，难点在于 1. 时间复杂度O(n)，空间复杂度O(1) -- 注定只能遍历元素，并且用单个变量来完成计数 2. 众数的条件是n/3 针对此题的n/3的进行深入分析，可以发现有三种情况： 1. 不存在大于n/3的众数，第一轮结束后，第二轮check时候就会把非众数都过滤掉。 2. 只存在1个大于n/3的众数, 其余元素个数总数小于2n/3。递减(pair out)时候可以保证众数的count不为0, 第二轮check时候 就会把非众数都过滤掉。 3. 存在2个大于n/3的众数，其余元素都小于n/3。递减(pair out)时候可以保证2个众数的count不为0, 第二轮check时候 就会把非众数都过滤掉。 Boyer-Moore Majority Vote algorithm的拓展： https://discuss.leetcode.com/topic/65042/my-understanding-of-boyer-moore-majority-vote https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>Majority Element</tag>
        <tag>Moore’s voting algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 169. Majority Element]]></title>
    <url>%2F2017%2F11%2F24%2FLeetCode%2FLeetCode-MajorityElement%2F</url>
    <content type="text"><![CDATA[题目描述：Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.You may assume that the array is non-empty and the majority element always exist in the array. 题目大意：给定一个长度为n的数组，寻找其中的“众数”。众数是指出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的并且数组中的众数永远存在。 参考LeetCode Discuss：https://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution/20https://discuss.leetcode.com/topic/17446/6-suggested-solutions-in-c-with-explanations 解题思路1： HashTable：使用HashTasble给每个出现的元素计数，遍历数组，发现超过半数的众数就返回。 C++代码：1234567891011class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; mapNums; for (int i = 0; i &lt; nums.size(); ++i) &#123; ++mapNums[nums[i]]; if (mapNums[nums[i]] &gt; nums.size() / 2) return nums[i]; &#125; return 0; &#125;&#125;; 代码分析：时间复杂度满足O(n)，但是由于HashTable（unordered_map）的存在，空间复杂度就不能满足O(1)。 解题思路2： 排序：排序的结果就是众数如果存在，中间的元素一定是众数（过半） C++代码：1234567class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); return (nums.size() / 2); &#125;&#125;; 代码分析： 时间复杂度主要在排序上， N*log2(N) 如果数组为空或者不存在众数，上述代码需要考虑更全面些 123456789101112131415161718class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int pivot = nums.size() / 2; int count = 0; for (int i = pivot; i &lt; nums.size(); i++) &#123; if (nums[pivot] != nums[i]) break; count++; &#125; for (int i = pivot - 1; i &gt;= 0; i--) &#123; if (nums[pivot] != nums[i]) break; count++; &#125; if (count &gt; pivot) return nums[pivot]; else return 0; &#125;&#125;; 解题思路3： 投票算法：遍历元素，利用candidate 和 count两个变量找到众数。（前提：众数一定存在） C++代码：1234567891011121314class Solution &#123;public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; int major = nums, counts = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (!counts) &#123; major = nums[i]; counts = 1; &#125; else counts += (nums[i] == major) ? 1 : -1; &#125; return major; &#125;&#125;; 代码分析：Moore’s voting algorithm是比较有意思的一个算法，在dicuss上看到的。这个算法是解决这样一个问题：从一个数组中找出出现半数以上的元素。大意是这样： We will sweep down the sequence starting at the pointer position shown above. As we sweep we maintain a pair consisting of a current candidate and a counter. Initially, the current candidate is unknown and the counter is 0.When we move the pointer forward over an element e: If the counter is 0, we set the current candidate to e and we set the counter to 1. If the counter is not 0, we increment or decrement the counter according to whether e is the current candidate.When we are done, the current candidate is the majority element, if there is a majority. “投票算法”设定两个变量candidate和count。candidate保存当前可能的候选众数，count保存该候选众数的出现次数。遍历数组num。如果当前的数字e与候选众数candidate相同，则将计数count + 1否则，如果当前的候选众数candidate为空，或者count为0，则将候选众数candidate的值置为e，并将计数count置为1。否则，将计数count - 1最终留下的候选众数candidate即为最终答案。以上算法时间复杂度为O(n)，空间复杂度为O(1) 官方解析：时间复杂度: O(n2) — 蛮力法: 依次检查每一个元素是否为众数时间复杂度: O(n), 空间复杂度: O(n) — 哈希表: 维护一个每一个元素出现次数的哈希表, 然后找到出现次数最多的元素时间复杂度: O(n log n) — 排序: 在排序后找出连续重复出现次数最多的元素平均时间复杂度: O(n), 最坏复杂度: 无穷大 — 随机算法: 随机选取一个元素计算其是否为众数. 如果不是, 就重复上一步骤直到找到为止。 由于选出众数的概率 &gt; 1 / 2, 因此期望的尝试次数 &lt; 2时间复杂度: O(n log n) — 分治法: 将数组拆成2半, 然后找出前一半的众数A和后一半的众数B。则全局众数要么是A要么是B。 如果 A == B, 则它自然而然就是全局众数。 如果不是, 则A和B都是候选众数, 则至多只需要检查这两个元素的出现次数即可。 时间复杂度, T(n) = T(n/2) + 2n = O(n log n).时间复杂度: O(n) — Moore投票算法: 我们维护一个当前的候选众数和一个初始为0的计数器。遍历数组时，我们看当前的元素x: * 如果计数器是0, 我们将候选众数置为 x 并将计数器置为 1 * 如果计数器非0, 我们根据x与当前的候选众数是否相等对计数器+1或者-1 * 一趟之后, 当前的候选众数就是所求众数. 时间复杂度 = O(n). 时间复杂度: O(n) — 位操作法: 我们需要32次迭代, 每一次计算所有n个数的第i位的1的个数。由于众数一定存在，那么或者1的个数&gt;0的个数 或者反过来(但绝不会相同)。 众数的第i位一定是计数较多数字。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>Sort</tag>
        <tag>HashTable</tag>
        <tag>Majority Element</tag>
        <tag>Moore’s voting algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 121. Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017%2F11%2F23%2FLeetCode%2FLeetCode-BestTimetoBuyandSellStock%2F</url>
    <content type="text"><![CDATA[题目描述：Say you have an array for which the ith element is the price of a given stock on day i.If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 题目大意：给一个数组prices[]，prices[i]代表股票在第i天的售价，求出只做一次交易(一次买入和卖出)能得到的最大收益。 解题思路1： Brute &amp; Force（直观做法）: 两个循环，逐一找到每两个元素的差值，取最大的即为为maxProfit，时间复杂度O(n^2) C++代码：1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxProfit = 0; for (int i = 0; i &lt; prices.size(); i++) &#123; for (int j = i + 1; j &lt; prices.size(); j++) &#123; if (0 &lt; prices[j] - prices[i]) maxProfit = max(prices[j] - prices[i], maxProfit); &#125; &#125; return maxProfit; &#125;&#125;; 代码分析： 1. 遍历数组，找到MaxProfit（效率较低） 2. 保证每一次比较的差值都是正值即可 解题思路2： 根据题目意思，只需要找出一次交易的最大的差值。对于此题就是要找到最小值（下限）和最大值（上限）。只要能固定住其中之一，就可以通过一次遍历，时间复杂度O(n)，找到maxProfit.参考LeetCode Discuss：https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/2https://discuss.leetcode.com/topic/2763/a-o-1-n-solution C++代码：12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxProfit = 0; int minPrice = INT_MAX; for (int i = 0; i &lt; prices.size(); i++) &#123; minPrice = min(minPrice, prices[i]); maxProfit = max(maxProfit, prices[i] - minPrice); &#125; return maxProfit; &#125;&#125;; 代码分析： 1. 将如何获得maxProfit的问题转化为：取出maxProfit和prices[i] - minPrice之间的最大差值 2. 通过观察发现并不是每一次迭代都需要去计算minPrice，可以优化为以下代码 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maxProfit = 0; int minPrice = INT_MAX; for (int i = 0; i &lt; prices.size(); i++) &#123; if (prices[i] &lt; minPrice) minPrice = min(minPrice , prices[i]); maxProfit = max(maxProfit, prices[i] - minPrice); &#125; return maxProfit; &#125;&#125;; 拓展: Kadane’s Algorithm]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>Kadane&#39;s Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 122. Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2017%2F11%2F21%2FLeetCode%2FLeetCode-BestTimetoBuyandSellStockII%2F</url>
    <content type="text"><![CDATA[题目描述：Say you have an array for which the ith element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 题目大意：假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。给出一个数组样例[2,1,2,0,1], 返回 2 解题思路： 这个是一道DP(动态规划)的题。总的来说就是如何N天的总利润如何最大呢？就是一旦有获利空间就去赚钱，所以就是把每两天的价格增长量加起来就是总利润了，如果存在两天的价格增长量为负，那么就不进行交易。同一天买卖，收益为0，所以需要隔天买卖，保证利润增值。参考LeetCode Discuss：https://discuss.leetcode.com/topic/17081/three-lines-in-c-with-explanation C++代码：1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt; &amp;prices) &#123; int ret = 0; for (size_t p = 1; p &lt; prices.size(); ++p) // Only consider positive value to make sure get max profit ret += max(prices[p] - prices[p - 1], 0); return ret; &#125;&#125;; 代码分析： 1. 题意为给定一个数组，数组中第i个元素的值对应着第i天的股票，你可以完成多次交易，但是每次交易只能买入一次并卖出,求进行 多次交易所能得到的最大利润。该题为Best Time to Buy and Sell Stock的加强版。 2. 与Best Time to Buy and Sell Stock类似，该题同样考查的是最大差值。只不过该题考查数组中所有相邻且递增元素 的数值之差的总和。只要第i+1天的值大于第i天的值，则可买入，求得利润（差值），遍历整个数组，得到所用差值之和即为总的利润。 负值则跳过。充分体现了DP的精髓，局部最优就是整体最优解。 3. 假设有四个数字，&quot;a &lt;= b &lt;= c &lt;= d&quot;, the profit is &quot;d - a = (b - a) + (c - b) + (d - c)&quot;。 例如[5,8,9,10],maxProfit=(8-5)+(9-8)+(10-9)=10-5=5; // 这是理想情况 假如其中有负值，则跳过这几个元素，直到获取正值，保证利润都是递增。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>DP</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 463. Island Perimeter]]></title>
    <url>%2F2017%2F11%2F17%2FLeetCode%2FLeetCode-IslandPerimeter%2F</url>
    <content type="text"><![CDATA[题目描述：You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.Example:123456[[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]Answer: 16 Explanation: The perimeter is the 16 yellow stripes in the image below: 题目大意：给定一个二维地图，1表示陆地，0表示水域。单元格水平或者竖直相连（不含对角线）。地图完全被水域环绕，只包含一个岛屿（也就是说，一个或者多个相连的陆地单元格）。岛屿没有湖泊（岛屿内部环绕的水域）。单元格是边长为1的正方形。地图是矩形，长宽不超过100。计算岛屿的周长。 解题思路1： DFS：深度优先遍历（递归实现）, 虑每个元素的四个方向，如果是边界或者0，则perimeter+1。参考LeetCode Discuss：https://discuss.leetcode.com/topic/106301/java-c-straightforward-dfs-solutionhttps://discuss.leetcode.com/topic/106261/java-c-clean-code C++代码：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); int nums = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (1 == grid[i][j]) nums += bfs(grid, i, j); &#125; &#125; return nums; &#125;private: int dfs(vector&lt;vector&lt;int&gt; &gt;&amp; grid, int i, int j) &#123; if (i &lt; 0 || i &gt;= grid.size() || j &lt; 0 || j &gt;= grid[0].size() || 0 == grid[i][j]) return 1; // stripes else if (-1 == grid[i][j]) return 0; else &#123; grid[i][j] = -1; // mark visited return dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1); &#125; &#125;&#125;; 代码分析： 1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素 2. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)] 3. 如果是边界点或者grid[i][j]为0的情况，则perimeter + 1 4. 访问过的元素置为-1，与原数组元素值区分。 5. 二维数组的vector表示 123456789int arr[4][4] = &#123;&#123;0,1,0,0&#125;,&#123;1,1,1,0&#125;,&#123;0,1,0,0&#125;,&#123;1,1,0,0&#125;&#125;;vector&lt;vector&lt;int&gt; &gt; grid(4);for (int i = 0; i &lt; grid.size(); i++) grid[i].resize(4);for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; grid[i][j] = arr[i][j]; &#125;&#125; 解题思路2： BFS：广度优先遍历（借助队列迭代实现）参考LeetCode Discuss： C++代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt; &gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); int nums = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (1 == grid[i][j]) nums += bfs(grid, i, j); &#125; &#125; return nums; &#125;private: int bfs(vector&lt;vector&lt;int&gt; &gt;&amp; grid, int i, int j) &#123; queue&lt;pair&lt;int, int&gt; &gt; q; grid[i][j] = -1; // visited vector&lt;int&gt; dir(&#123;-1, 0, 1, 0, -1&#125;); // c++11/14 // int nums[] = &#123;-1, 0, 1, 0, -1&#125;; // vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int)); q.push(pair&lt;int, int&gt;(i, j)); int nums = 0; while (0 &lt; q.size()) &#123; int m = q.front().first; // row index int n = q.front().second; // col index q.pop(); // remove from queue for (int idx = 0; idx &lt; dir.size() - 1; idx++) &#123; int rowIdx = m + dir[idx]; // row index int colIdx = n + dir[idx + 1]; // col index if (rowIdx &lt; 0 || rowIdx &gt;= grid.size() || colIdx &lt; 0 || colIdx &gt;= grid[0].size() || 0 == grid[rowIdx][colIdx]) nums++; // accumulate stripes else if (-1 == grid[rowIdx][colIdx]) continue; // skip visted item else &#123; q.push(pair&lt;int, int&gt;(rowIdx, colIdx)); grid[rowIdx][colIdx] = -1; // mark visited &#125; &#125; &#125; return nums; &#125;&#125;; 代码分析： 1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素 2. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)] 3. 如果是边界点或者grid[i][j]为0的情况，则perimeter + 1 4. 访问过的元素置为-1，与原数组元素值区分。 5. 二维数组的vector表示 123456789int arr[4][4] = &#123;&#123;0,1,0,0&#125;,&#123;1,1,1,0&#125;,&#123;0,1,0,0&#125;,&#123;1,1,0,0&#125;&#125;;vector&lt;vector&lt;int&gt; &gt; grid(4);for (int i = 0; i &lt; grid.size(); i++) grid[i].resize(4);for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; grid[i][j] = arr[i][j]; &#125;&#125; 解题思路3： 代码简洁的全遍历，复杂度O(n)。参考LeetCode Discuss：https://discuss.leetcode.com/topic/111260/c-short-and-fast-beats-93 C++代码：123456789101112class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int p = 0; for (int i = 0; i &lt; grid.size(); ++i) for (int j = 0; j &lt; grid[i].size(); ++j) if (grid[i][j] == 1) p += (i == 0 || grid[i - 1][j] == 0) + (i == grid.size() - 1 || grid[i + 1][j] == 0) + (j == 0 || grid[i][j - 1] == 0) + (j == grid[i].size() - 1 || grid[i][j + 1] == 0); return p; &#125;&#125;; 代码分析： 1. 代的方式进行全遍历，代码比较简洁。不过就是循环内嵌套过多的逻辑判断，效率比较低。 2. 关注点在确定当前grid[i][j]为1后，观察四个方向的元素是否为0，如果是则+1.如果是i = 0或者j=0的边界则直接+1； 解题思路4： 1. 确定“1”的个数，如果没有相邻包围的元素的话，perimeter为“1”的个数×4 2. 确定相邻的元素边界墙的个数，需要减去从上述结果中减去2×边界墙个数 参考LeetCode Discuss：https://discuss.leetcode.com/topic/68845/c-solution-with-explanation C++代码：12345678910111213141516171819class Solution &#123;public: int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int count=0, repeat=0; for(int i=0;i&lt;grid.size();i++) &#123; for(int j=0; j&lt;grid[i].size();j++) &#123; if(grid[i][j]==1) &#123; count ++; if(i!=0 &amp;&amp; grid[i-1][j] == 1) repeat++; if(j!=0 &amp;&amp; grid[i][j-1] == 1) repeat++; &#125; &#125; &#125; return 4*count-repeat*2; &#125;&#125;; 代码分析：总周长perimeter的解法一般两种： 1. “1”元素总长-相邻边×2 2. perimeter=边界元素个数+与“0”相邻元素个数]]></content>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 200. Number of Islands]]></title>
    <url>%2F2017%2F11%2F17%2FLeetCode%2FLeetCode-NumberofIslands%2F</url>
    <content type="text"><![CDATA[题目描述：Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.Example 1:123411110110101100000000 Answer: 1Example 2:123411000110000010000011 Answer: 3 题目大意：给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。测试样例见题目描述 解题思路1： DFS：深度优先遍历（递归实现）参考LeetCode Discuss：https://discuss.leetcode.com/topic/106261/java-c-clean-codehttps://discuss.leetcode.com/topic/13045/my-accepted-c-solution-may-be-trivial C++代码：12345678910111213141516171819202122232425262728293031323334353637class Solution&#123;public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123; if (0 == grid.size() || 0 == grid[0].size()) return 0; int numIslands = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if ('1' == grid[i][j]) &#123; numIslands++; bfs(grid, i, j); &#125; &#125; &#125; return numIslands; &#125;private: void dfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int i, int j) &#123; if (0 &gt; i || i &gt;= grid.size() || 0 &gt; j || j &gt;= grid[0].size() || '0' == grid[i][j]) return; grid[i][j] = '0'; // mark the value to avoid duplication vector&lt;int&gt; dir(&#123;-1, 0, 1, 0, -1&#125;); // c++11/14 // int nums[] = &#123;-1, 0, 1, 0, -1&#125;; // vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int)); for (int idx = 0; idx &lt; dir.size() - 1; idx++) &#123; int rowIdx = i + dir[idx]; // row index int colIdx = j + dir[idx + 1]; // col index dfs(grid, rowIdx, colIdx); &#125; &#125;&#125;; 代码分析： 1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素 2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0 3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)] 4. 由于是字符数组，在dfs迭代过程中，先要判断是否存在空数组情况，即‘[]’. 解题思路2： BFS：广度优先遍历（借助队列迭代实现）参考LeetCode Discuss：https://discuss.leetcode.com/topic/11589/dfs-and-bfs-in-c C++代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution&#123;public: int numIslands(vector&lt;vector&lt;char&gt; &gt;&amp; grid) &#123; if (0 == grid.size() || 0 == grid[0].size()) return 0; int numIslands = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if ('1' == grid[i][j]) &#123; numIslands++; bfs(grid, i, j); &#125; &#125; &#125; return numIslands; &#125;private: void bfs(vector&lt;vector&lt;char&gt; &gt;&amp; grid, int i, int j) &#123; queue&lt;pair&lt;int, int&gt; &gt; q; q.push(pair&lt;int, int&gt;(i, j)); grid[i][j] = '0'; // mark the value to avoid duplication vector&lt;int&gt; dir(&#123;-1, 0, 1, 0, -1&#125;); // c++11/14 // int nums[] = &#123;-1, 0, 1, 0, -1&#125;; // vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int)); while (0 &lt; q.size()) &#123; int m = q.front().first; // row index int n = q.front().second; // col index q.pop(); // remove from queue for (int idx = 0; idx &lt; dir.size() - 1; idx++) &#123; int rowIdx = m + dir[idx]; int colIdx = n + dir[idx + 1]; if (0&lt;=rowIdx &amp;&amp; rowIdx&lt;grid.size() &amp;&amp; 0&lt;=colIdx &amp;&amp; colIdx&lt;grid[0].size() &amp;&amp; '1'==grid[rowIdx][colIdx]) &#123; q.push(pair&lt;int, int&gt;(rowIdx, colIdx)); grid[rowIdx][colIdx] = '0'; &#125; &#125; &#125; &#125;&#125;; 代码分析： 1. BFS的处理需要借助数组实现，每一次将grid范围内其值为1的元素塞进数组（后续元素为当前grid[i][j]四个方向上的邻接元素） 2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0 3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)] 4. 由于是字符数组，在dfs迭代过程中，先要判断是否存在空数组情况，即‘[]’.]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 695. Max Area of Island]]></title>
    <url>%2F2017%2F11%2F16%2FLeetCode%2FLeetCode-MaxAreaofIsland%2F</url>
    <content type="text"><![CDATA[题目描述：Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)Example 1:12345678[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.Example 2:1[[0,0,0,0,0,0,0,0]] Given the above grid, return 0.Note: - The length of each dimension in the given grid does not exceed 50. 题目大意：给定二维格子grid，上下左右相邻的1组成岛屿，求岛屿的最大面积。 解题思路1： DFS：深度优先遍历（递归实现）参考LeetCode Discuss：https://discuss.leetcode.com/topic/106301/java-c-straightforward-dfs-solutionhttps://discuss.leetcode.com/topic/106261/java-c-clean-code C++代码：1234567891011121314151617181920212223242526272829class Solution&#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); int maxArea = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (1 == grid[i][j]) &#123; maxArea = max(maxArea, dfs(grid, i, j)); &#125; &#125; &#125; return maxArea; &#125;private: int dfs(vector&lt;vector&lt;int&gt; &gt;&amp; grid, int i, int j) &#123; if (0 &gt; i || i &gt;= grid.size() || 0 &gt; j || j &gt;= grid[0].size() || 0 == grid[i][j]) return 0; grid[i][j] = 0; // mark the value to avoid duplication return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1); &#125;&#125;; 代码分析： 1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素 2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0 3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)] 解题思路2： BFS：广度优先遍历（借助队列迭代实现）参考LeetCode Discuss：https://discuss.leetcode.com/topic/106274/c-bfs-dfs-concise-code C++代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution&#123;public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(); int n = grid[0].size(); int maxArea = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (1 == grid[i][j]) &#123; maxArea = max(maxArea, bfs(grid, i, j)); &#125; &#125; &#125; return maxArea; &#125;private: int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(pair&lt;int, int&gt;(i, j)); int maxArea = 1; grid[i][j] = 0; // mark the value to avoid duplication vector&lt;int&gt; dir(&#123;-1, 0, 1, 0, -1&#125;); while (0 &lt; q.size()) &#123; int m = q.front().first; // row index int n = q.front().second; // col index q.pop(); // remove from queue for (int idx = 0; idx &lt; dir.size() - 1; idx++) &#123; int rowIdx = m + dir[idx]; int colIdx = n + dir[idx + 1]; if (0&lt;=rowIdx &amp;&amp; rowIdx&lt;grid.size() &amp;&amp; 0&lt;=colIdx &amp;&amp; colIdx&lt;grid[0].size() &amp;&amp; 1==grid[rowIdx][colIdx]) &#123; q.push(pair&lt;int, int&gt;(rowIdx, colIdx)); maxArea++; grid[rowIdx][colIdx] = 0; &#125; &#125; &#125; return maxArea; &#125;&#125;; 代码分析： 1. BFS的处理需要借助数组实现，每一次将grid范围内其值为1的元素塞进数组（后续元素为当前grid[i][j]四个方向上的邻接元素） 2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0 3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 697. Degree of an Array]]></title>
    <url>%2F2017%2F11%2F15%2FLeetCode%2FLeetCode-DegreeofanArray%2F</url>
    <content type="text"><![CDATA[题目描述：Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.Example 1:1234567Input: [1, 2, 2, 3, 1]Output: 2Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2:12Input: [1,2,2,3,1,4,2]Output: 6 Note: - nums.length will be between 1 and 50,000. - nums[i] will be an integer between 0 and 49,999. 题目大意：给定非空非负整数数组，数组的度是指元素的最大出现次数。寻找最大连续区间，使得区间的度与原数组的度相同。 解题思路1： 数组mapCnt记录元素的出现个数数组mapMax记录元素的最大degreestartIdx和endIdx记录元素的最小和最大下标（length = endIdx - startIdx + 1）遍历即可参考LeetCode Discuss：https://discuss.leetcode.com/topic/107102/my-accepted-c-solution-o-n/3 C++代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int findShortestSubArray(vector&lt;int&gt;&amp; nums)&#123; map&lt;int, int&gt; mapCnt; int max = 0; int min = 0; if (true == doFineSubArray(nums, mapCnt)) &#123; map&lt;int,int&gt;::iterator it; for (it = mapCnt.begin(); it != mapCnt.end(); ++it) &#123; if (it-&gt;second &gt; max) max = it-&gt;second; &#125; map&lt;int, int&gt; mapMax; for (it = mapCnt.begin(); it != mapCnt.end(); ++it) &#123; if (it-&gt;second == max) mapMax.insert(pair&lt;int , int&gt;(it-&gt;first, it-&gt;second)); &#125; max = 0; for (it = mapMax.begin(); it != mapMax.end(); ++it) &#123; int beginIdx = 0; for (int idx = 0; idx &lt; nums.size(); idx++) &#123; if (nums[idx] == it-&gt;first) &#123; beginIdx = idx; break; &#125; &#125; int endIdx = 0; for (int idx = nums.size() - 1; 0 &lt;= idx; idx--) &#123; if (nums[idx] == it-&gt;first) &#123; endIdx = idx; break; &#125; &#125; int length = endIdx - beginIdx + 1; if (0 == min) min = length; else min = (min &lt; length) ? min : length; &#125; &#125; return min;&#125;bool doFineSubArray(vector&lt;int&gt;&amp; nums, map&lt;int, int&gt;&amp; mapCnt)&#123; for (int idx = 0; idx &lt; nums.size(); idx++) &#123; if (0 != mapCnt.count(nums[idx])) ++mapCnt[nums[idx]]; else mapCnt.insert(pair&lt;int , int&gt;(nums[idx], 1)); &#125; if (0 &lt; mapCnt.size()) return true; else return true;&#125; 代码分析： 1. 这中解法如果出现nums={1, 2, 3}时候，最后的循环遍历时间复杂度会变成0(n^2) 2. std::map的本质是红黑树，查找的时间复杂度是O(nlogn). 3. C++中的hashtable，可以考虑unordered_map（C++11/14）. 解题思路2： 数组unordered_map]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Algorithms</tag>
        <tag>Data Structure</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给Hexo添加Gitment评论插件]]></title>
    <url>%2F2017%2F08%2F04%2FOthers%2FAddGitmentToNext%2F</url>
    <content type="text"><![CDATA[前言 今年六一略显不同，多说正式关闭服务, 蓝后，7月6号网易云跟帖也关了。在这个多事之秋。国内的评论系统纷纷倒闭。一直想给博客加个靠谱的评论系统，只能求助于谷歌，搜索一番之后，不经意间看到了，imsun实现的一款基于 GitHub Issues 的评论系统Gitment。Gitment是作者imsun实现的一款基于GitHub Issues的评论系统。 支持在前端直接引入, 不需要任何后端代码。 可以在页面进行登录、查看、评论、点赞等操作。同时有完整的 Markdown / GFM 和代码高亮支持，尤为适合各种基于 GitHub Pages 的静态博客或项目页面。本篇文章仅介绍在hexo-NexT中添加Gitment评论插件, 并且增加一个点开显示评论的按钮, 对于 Gitment 的使用请参考imsun的博客。 一、注册github OAuth Application Gitment是使用的GitHub Issues作为评论系统，在接入Gitment前，需要获得GitHub的授权，获得相应的客户端id和客户端私钥，以备站点使用。具体步骤如下图所示：OAuth application注册接入： 在github主页头像-&gt;setting下面，填入相关信息如下注册完毕，得到owner、client_id、client_secret。 二、添加 Gitment 插件 打开/next/layout/_partials/comments.swig文件, 在最后一个 elseif 代码块下面添加Gitment相关的内容。1234567891011121314151617181920212223242526272829303132333435363738&#123;% elseif theme.changyan.appid and theme.changyan.appkey %&#125; &lt;div id=&quot;SOHUCS&quot;&gt;&lt;/div&gt;&#123;% elseif theme.gitment.enable %&#125; &lt;div onclick=&quot;showGitment()&quot; id=&quot;gitment_title&quot; class=&quot;gitment_title&quot;&gt;显示 Gitment 评论&lt;/div&gt; &lt;div id=&quot;container&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://imsun.github.io/gitment/style/default.css&quot;&gt; &lt;script src=&quot;https://imsun.github.io/gitment/dist/gitment.browser.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const myTheme = &#123; render(state, instance) &#123; const container = document.createElement(&apos;div&apos;); container.lang = &quot;en-US&quot;; container.className = &apos;gitment-container gitment-root-container&apos;; container.appendChild(instance.renderHeader(state, instance)); container.appendChild(instance.renderEditor(state, instance)); container.appendChild(instance.renderComments(state, instance)); container.appendChild(instance.renderFooter(state, instance)); return container; &#125; &#125; function showGitment() &#123; $(&quot;#gitment_title&quot;).attr(&quot;style&quot;, &quot;display:none&quot;); $(&quot;#container&quot;).attr(&quot;style&quot;, &quot;&quot;).addClass(&quot;gitment_container&quot;); var gitment = new Gitment(&#123; id: window.location.pathname, theme: myTheme, owner: &apos;&#123;&#123; theme.gitment.owner &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitment.repo &#125;&#125;&apos;, oauth: &#123; client_id: &apos;&#123;&#123; theme.gitment.client_id &#125;&#125;&apos;, client_secret: &apos;&#123;&#123; theme.gitment.client_secret &#125;&#125;&apos; &#125; &#125;); gitment.render(&apos;container&apos;); &#125; &lt;/script&gt;&#123;% endif %&#125; 然后打开NexT主题的_config.yml文件, 在评论区域添加以下代码：1234567# Gitment commentsgitment: enable: true owner: xxxx #your github ID repo: xxxx #the name of repo to store comments() client_id: xxxx #your client ID client_secret: xxxx #your client 我的配置信息如下： 三、“显示 Gitment 评论” 的按钮样式 在 next/source/css/_common/components 目录中新建一个 gitment.styl 的 css 样式文件, 复制以下代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.gitment_title:hover &#123; color: #fff; background: #0a9caf; background-image: initial; background-position-x: initial; background-position-y: initial; background-size: initial; background-repeat-x: initial; background-repeat-y: initial; background-attachment: initial; background-origin: initial; background-clip: initial; background-color: rgb(10, 156, 175);&#125;.gitment_title &#123; border: 1px solid #0a9caf; border-top-color: rgb(10, 156, 175); border-top-style: solid; border-top-width: 1px; border-right-color: rgb(10, 156, 175); border-right-style: solid; border-right-width: 1px; border-bottom-color: rgb(10, 156, 175); border-bottom-style: solid; border-bottom-width: 1px; border-left-color: rgb(10, 156, 175); border-left-style: solid; border-left-width: 1px; border-image-source: initial; border-image-slice: initial; border-image-width: initial; border-image-outset: initial; border-image-repeat: initial; border-radius: 4px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px;&#125;.gitment_title &#123; display: inline-block; padding: 0 15px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; color: #0a9caf; cursor: pointer; font-size: 14px;&#125; 然后打开同目录中的 components.styl 文件, 找个顺眼的位置添加一句1@import &quot;gitment&quot;; 四、为每篇博文初始化评论系统 由于gitment的原理是为每一遍博文以其URL作为标识创建一个github issue，对该篇博客的评论就是对这个issue的评论。因此，我们需要为每篇博文初始化一下评论系统， 初始化后，你可以在你的github上会创建相对应的issue。前面的步骤完成，重新部署网站后，你就可以在你的博文页下面看到一个评论框，还有看到以下错误Error: Comments Not Initialized，提示该篇博文的评论系统还没初始化。 点击Login with GitHub后，使用自己的github账号登录后， 就可以在上面错误信息处看到一个Initialize Comments的按钮。 (注意: 由于要求回调URL和当前地址一样，故第2步不能在本地调试， 需把代码先上传部署到服务器以后再调试，即hexo s是看不到效果的，只有hexo g &amp;&amp; hexo d才行)。 点击Initialize Comments按钮后，就可以开始对该篇博文开始评论了， 同时也可以在对应的github仓库看到相应的issue。 五、安装中遇到问题 获取对应数据ID 在配置owner的时候，可以在浏览器中输入：https://api.github.com/users/GitHub用户名，来获取对应数据id。 配置主题文件_config.yml时，格式错误，比如gitment前有空格也会造成代码生成问题。 Error: Not Found问题，repo库填写问题，详见gitment issues 18。 Not Found问题，基本上是因为NexT主题的_config.yml文件里，配置信息不对。一般是Github ID填错，或者repo填错(git评论仓库的名称，不是git仓库地址)。 其他问题，参见作者项目的Issue。 四、后记 以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。 https://github.com/imsun/gitment https://imsun.net/posts/gitment-introduction/ https://meesong.github.io/StaticBlog/2017/NexT+Gitment/ https://zonghongyan.github.io/2017/06/29/201706292034/]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Next</tag>
        <tag>Hexo</tag>
        <tag>Gitment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用七牛为Hexo存储图片]]></title>
    <url>%2F2017%2F08%2F02%2FOthers%2FUseQiniudnToStorePic%2F</url>
    <content type="text"><![CDATA[搭建完博客之后一直使用本地图片（相对路径），这样不是很方便，毕竟事关逼格。网上搜索了一把，貌似七牛云做图床评价挺高。说干就干，咱也尝试着使用七牛作为博客的图床了。 一、七牛是什么 七牛 是一个云存储服务商，注册并实名认证之后，你将免费享有 10GB 存储空间，每月 10GB 下载流量、100 万次 GET 请求、 10 万次 PUT/DELETE 请求。这对于一个博客来说，完全足够了。 二、为什么选用七牛 与直接部署到站点相比： 访问速度更快 （特别是对比部署到github的情况）。 对个人用户而言空间和流量都十分阔绰。 Gitcafe有 512Mb 的总空间限制，Github虽没有找到类似的说明，但是在其上托管过多媒体资源也不是太合适的做法。而在七牛，你甚至可以通过邀请好友来增加每月下载流量（我的邀请链接），每成功邀请一名朋友将增加5GB的下载流量，最高上限可达40GB。 如果你爱折腾，还可以玩出更多花样3： 防盗链； 对图片、音视频等在线处理，不必自己做重复工作。通过调用接口，七牛可以帮你：加水印、自定义裁剪区域、旋转、调整图片质量、转换格式； 分析下载量等详细数据，挖掘用户行为。 与其他上传站点相比： 更稳定：七牛毕竟是老牌服务商，数据的安全性和稳定性都较有保证。如果上传到什么小网站，哪天发现图片都打不开了才是人间惨剧~ 更灵活：配合 hexo-qiniu-sync 插件4，就算是七牛以后更改了空间域名，也不用一篇一篇地去改外链地址，只要在配置文件中修改外链前缀即可。 更方便：配合 hexo-qiniu-sync 插件，不必”上传→复制链接→引用外链“，直接按照本地路径引用，然后键入一条命令同步到七牛就好。会自动识别哪些是新增、修改的文件需要上传，哪些是原有的文件不需改动，十分方便。 当然，虽然七牛有很多优点，但是有一些不足： 在线文件管理不支持目录。 本地删除文件，云端不能同步删除文件。尽管仍有欠缺，私以为七牛依旧是现在个人博客最佳的资源储存服务。 三、七牛存储空间的设置 申请七牛账号 选择对象存储创建存储空间 配置相关参数 点击页面右上角头像→进入”个人中心“→选择”密钥管理“→复制当前使用中的AK和SK(待会设置插件时会用到)。 四、设置 hexo-qiniu-sync 插件 前人栽树，后人乘凉。有了插件hexo-qiniu-sync，可以不用手动上传文件到七牛，插件会自动帮你将本地目录的文件同步到七牛之前设定的存储空间下。 安装插件在hexo主目录下运行以下命令进行安装1npm install hexo-qiniu-sync --save 添加插件配置信息在hexo主目录下找到配置文件 _config.yml, 加入以下配置信息：12345678910111213141516171819202122#七牛云存储设置qiniu: offline: false sync: true bucket: bucket_name secret_file: sec/qn.json or C: access_key: AccessKey secret_key: SecretKey dirPrefix: static urlPrefix: http://bucket_name.qiniudn.com/static up_host: http://upload.qiniu.com local_dir: static update_exist: true image: folder: images extend: js: folder: js css: folder: css audio: folder: audio 几个注意点: bucket ：修改为你刚才申请的七牛空间名称 access_key 、 secret_key : 上传密钥AccessKey、SecretKey。即3 第3步复制的AK和SK。 urlPrefix : 七牛空间地址的前缀。 重要！必填！因为现在七牛已经取消了二级域名，外链前缀类似设置中的 http://7xqb0u.com1.z0.glb.clouddn.com ，插件不能根据 bucket 自动生成外链前缀了。你可以进入自己创建的空间在域名设置中看到自己的七牛测试域名，也可以查看一个已上传的文件外链地址，确认前缀无误。这个参数的设置是保证解析成网页文件时，外链地址正确的关键之一！ 不要在plugins下面添加hexo-qiniu-sync的配置项，否则会导致错误，详见 123# 错误示例plugins: - hexo-qiniu-sync 配置参数说明： offline 参数：如果要使用同步到七牛空间的静态资源，请设置为 false。如果只想浏览在本地的静态资源文件，则设置为 true。 secret_file 参数： 可有可无，貌似有了这个之后上面的两个参数就不需要配置了。这个路径是需要你自己建立一个json的文件存储上面的秘钥，然后把文件的路径写在这里就好 sync 参数：如果你想关掉七牛同步，将此参数设置为false即可，不过一般用不到修改这个参数。 dirPrefix 参数：将资源上传到七牛空间内这个目录下(说是目录会容易理解点)，默认为 static 目录。可设置为空。该参数会影响外链的地址，如果设置为非空值，例如默认值 static ，则 urlPrefix 为保持一致需加上目录后缀 /static ，改为 http://bucket_name.qiniudn.com/static 。(外链地址http://bucket_name.qiniudn.com，替换成自己地址) urlPrefix 参数：七牛空间地址的前缀，会按默认格式自动生成地址，所以此参数可省略。默认格式为 http://bucket_name.qiniudn.com/static ，如果你的七牛空间使用自定义域名或域名不是此格式的，请配置此参数。当你设置了 dirPrefix 参数后，如static。则此url地址必须加上目录后缀 /static ， 即http://bucket_name.qiniudn.com/static，否则静态资源将无法访问。如果没有设置 dirPrefix 参数，url地址不必加上目录后缀， 即http://bucket_name.qiniudn.com。(外链地址http://bucket_name.qiniudn.com，替换成自己地址) local_dir 参数：只填写一个目录名称即可，建立在hexo博客的主目录，不需要使用子目录。当你在配置中填写好文件夹后，运行hexo时，会自动建立对应的目录。如果你了解hexo文件夹的关系，担心这样会导致离线模式不能查看到图片，我可以告诉你你不需要担心这个问题。在你以离线模式运行时，会自动使用软连接/联接方式帮你建立文件夹的引用，可以让你的离线浏览节省一倍的空间。 update_exist 参数：如果你的静态文件会进行修改或替换，并需要更新七牛空间上原先上传的文件，则设置为 true 。是否更新空间上已上传的文件，是按照对比文件大小是否相同或者本地文件在上传到七牛空间之后进行过修改的规则进行判断的。 image/js/css ：子参数folder为不同静态资源种类的目录名称，一般不需要改动 image : extend 参数：这是个特殊参数，是文章内使用 qnimg 标签引用图片的默认图片处理操作。请参考 七牛开发者中心-图片处理。可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图。 以下是我的配置文件 这样你在 local_dir 的image命名的文件夹中添加一张图片，之后运行hexo（如hexo s），图片就可以在你的七牛存储空间的内容管理中看见了。你会看到图片的外链URL就是http://your_site/your_static(你的目录-dirPrefix参数的配置)/images/yourimage.png。就是域名+自定义的目录名+images（配置文件中image中folder指定的文件）+ 图片名 五、引用七牛资源 引用图片图片的引用是最典型的情况。让我们来看最简单的情况：如果你想引用储存在 local_dir/images 下的图片 demo.jpg ，只需在文章中插入：1&#123;% qnimg demo.jpg %&#125; 生成站点时将被解析为：1&lt;img src=&quot;http://7xqb0u.com1.z0.glb.clouddn.com/images/demo.jpg&quot;&gt; 这里，我们总结一下生成的图片外链地址规则。我们把引用实例概括为：1&#123;% qnimg ImgFile %&#125; 则生成的图片外链地址规则为urlPrefix + / + image.folder + / + ImgFile。因此，要想正确的引用外链，一定要注意每一个步骤的设置。如果最后外链不能正常显示，首先对比一下网站博客引用的地址和七牛的外链地址是否一致，如果不一致，则对照外链地址的生成规律，检查文件存放路径、 urlPrefix 、 dirPrefix 、 image.folder 设置是否正确。 图片引用的高阶版高级用法的通用模版：1&#123;% qnimg imageFile [attr1:value1] [&apos;attr2:value21 value22 ...&apos;] [extend:... | normal:yes] %&#125; [] 表示可选项，按需添加，也可以不写| 表示二选一extend:… 图片处理参数，表示对图片进行某种特定处理5，多个处理之间用 | 间隔。normal:yes 表示使用原图，忽略 _config.yml 文件中的 image.extend 设置实例 图片的本地路径为 cdn/images/test/demo.png ：1&#123;% qnimg test/demo.png title:标题 alt:说明 &apos;class:class1 class2&apos; extend:?imageView2/2/w/600 %&#125; 解析为：1&lt;img title=&quot;标题&quot; alt=&quot;说明&quot; class=&quot;class1 class2&quot; src=&quot;http://7xqb0u.com1.z0.glb.clouddn.com/images/test/demo.png?imageView2/2/w/600&quot;&gt; 其中 ?imageView2/2/w/500 代表生成宽度最多500px的缩略图5。如果经常使用某种图片效果，可以在其七牛创建处理样式，以后直接将 extend 参数设置为 分隔符 + 样式名 就好。例如设置的分隔符为 - ，样式名为 new ，则 extend 参数为 -new 。 引用CSS和JS只是引用的标签名不同：12&#123;% qnjs jsFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; %&#125;&#123;% qncss cssFile attr1:value1 attr2:value2 &apos;attr3:value31 value32 value3n&apos; %&#125; 注意在添加图片的时候，放在images文件夹下的图片，是可以创建子文件夹的。所以，为了方便以及同时兼容之前使用本地图片插件的方式，每一篇文章或者一个功能对应的图片最好放在一个子文件夹下，这样在日志文章中对图片进行引用的时候就可以直接设置成文件夹名/图片名.png的格式。这里建议文件夹名与文章名相同，便于管理 六、同步到七牛 将文件上传到七牛云有两种方式 hexo s 和 hexo qiniu sync|sync2 的两个命令工具:12345678qiniu sync plugin for hexoUsage: hexo qiniu &lt;argument&gt;Description:hexo qiniu static files sync pluginArguments: info | i Displays plugin version, aurthor or GitHub links sync | s Sync your static files to qiniu. sync2 | s2 Sync your static files to qiniu.(And uploaded update files) 七、后记 以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。 https://github.com/gyk001/hexo-qiniu-sync http://www.ixirong.com/2016/10/31/how-to-use-hexo-qiniu-sync-plugin/ http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/ http://error408.com/2016/08/02/Hexo%E4%B8%83%E7%89%9B%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8/]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Qiniu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo环境搭建个人博客]]></title>
    <url>%2F2017%2F07%2F21%2FOthers%2FUseHexoToBuildBlog%2F</url>
    <content type="text"><![CDATA[很早之前就计划搭建一个博客，但由于各方面原因（最主要还是懒），一直耽误着。终于几个月前看到同事在弄，自己也开始折腾起来。 一路跌跌撞撞，也算初步搞定。特此把中间踩过的坑记录下来，也算对后来的道友有个交代。 一、前期准备服务器购买 我是用的是VPS（虚拟专用服务器）作为网站的服务器，选择了口碑较好的搬瓦工VPS，因为其价格便宜，稳定性强，并且还支持支付宝付款。关键的关键是VPS上安装了Shadowsocks以后就可以无忧访问外网了，比隔天就被封杀的VPN靠谱多了。 :) 搬瓦工官网注册完后，在Home页面有很多产品供我们选择，我之前选择的是最便宜的那款，2.99美刀一个月，如果觉得性能有瓶颈，可以考虑换个买4.99美刀一个月的，性能提升了一倍(毕竟2.99美刀的内存才256M)。每个直达方案通道里面，有具体方案的细节，筒子们可以自己研究下再做决定。 购买完成后，选择VPS Hosting-&gt;Services-&gt;My Services。然后可以看到已经购买的VPS。 服务器有了，下面当然就是给你的服务器安装操作系统。 点击KiwiVM Control Panel 选择Install new OS，我安装的是centos-6-x86，这个根据个人喜好选择。 装完好系统，我们可以看到自己VPS的服务器属性。 然后远程连接到服务器上。 网上有很多串口连接软件，我用的是Putty。 打开后，输入服务器的IP地址和端口号。 登录成功后，进入熟悉的命令行模式，至此VPS的购买就全部搞定啦！ 域名注册 对于网站的访问，我们可以通过IP地址直接访问，也可以通过域名来访问。 相比之下，域名更便于记忆。 当然为了此步骤更多是为了显得更专（zhuang）业（bi）。 具体步骤如下：域名注册网站： TK Namecheap Tk域名，网络上最容易申请到的免费域名之一，以TK结尾，与COM、NET、CN一样同属顶级域名。 因为是免费域名，很多人用来做垃圾网站，听说百度一般不会收录。 汗！经过网上的一番对比，最终还是选择了在Namecheap上注册域名。 购买好域名后，要配置下域名和我们的服务器IP地址的映射关系。 配置好后，可能需要等十来分钟后，才可以被DNS服务器正常解析。 关于NameCheap的映射关系配置，请参考链接: namecheap域名解析教程2017OK，恭喜你，前期工作准备完了！ 开罐可乐庆祝一下! :) 二、Hexo环境安装(本机Windows部署)当初也有很多博客框架的选择摆在我面前,但是我没有犹豫选择了Hexo。主要就是看中它的迅速快，号称使用Node.js让上百个页面在几秒内瞬间完成渲染；同时最关键的原因在于只需要一条命令就可以完成一键部署。 终极原因是因为懒 ～Hexo的官网上东西已经比较全了，大家动手前，可以先浏览一下官网，讲的还是很详细的关于建站这块。闲话不多说，让我们撸起袖子，荡起双桨，二话不说开始干。 基本思路 在本地生成静态文件，把静态文件部署到VPS上，用Nginx直接做Web服务，由于hexo支持git的部署方式，从而可以实现从本地更新博客，方便快捷。 安装Node.js 在Node.js官网下载最新版，一路默认安装。 安装Git 下载Git for windows一路默认next点下去。Git这里我们需要注意一下，需要配置一下环境变量。然后我们需要生成SSH密钥，按下面的步骤进行。 打开C:\Users\&lt;用户名&gt;\.ssh文件夹，如果没有就新建 在空白处单击右键，选择Git Bash Here打开终端 设置git用户名12git config --global user.email &quot;email@example.com&quot;git config --global user.name &quot;username&quot; 生成ssh密钥 一路回车生成公钥和密钥，一会要用到公钥id_rsa.pubssh-keygen -t rsa -C &quot;email@example.com&quot; 创建网站目录 在你电脑的任意位置创建一个文件夹（例如C:\hexo，下文以此代替），作为网站目录(名字可以任取)。 安装Hexo 打开cmd(以管理员权限运行)，通过cd命令进入hexo文件夹，输入node后执行如下命令(或者压根不用)1234npm install -g hexo-clihexo initnpm installhexo d -fg 运行完上述命令后,可以在C:\hexo文件夹下看到有以下的文件目录生成。 你可以看见hexo文件夹下有一个themes文件夹，这是可以自定义的，从而改变网站的呈现形式，Hexo官网也提供了一些可供选择的主题。 接着启动本地hexo serverhexo serve(或者hexo s)打开http://localhost:4000 即可看到你的站点（当然还没有发布到网络）。 如果没有响应的话，电脑重启一下，再敲入hexo serve(或者hexo s)启动本地hexo server的命令。 到这里，本地的网站部署和搭建就告一段落。 可以稍微休息下，准备部署VPS了。 三、部署Hexo(VPS部署)前面已经讲解过VPS的购买和系统安装，此处为Centos 6在root下的操作，关于连接VPS，Windows 用户请使用Putty（提示： Putty 中使用粘贴仅需鼠标右键）。关于vi操作，按下i键进入编辑模式，编辑结束后按esc键退出，这时按：，并输入 wq ，即可。 安装Git 在Putty终端输入如下命令：12yum update &amp;&amp; apt-get upgrade -y #更新内核yum install git-core 安装nginx 在Putty终端输入如下命令：yum install nginx -y 新建git用户添加sudo权限 在Putty终端输入如下命令：123adduser gitchmod 740 /etc/sudoers #改变权限值用于读写vim /etc/sudoers 在vi编辑中找到如下内容：12## Allow root to run any commands anywhererootALL=(ALL) ALL 在下面添加一行git ALL=(ALL) ALL保存并退出(vi里输入:wq，回车执行)后执行chmod 440 /etc/sudoers #改回原来的权限值 创建git仓库，并配置ssh登录 12345678su gitcd ~mkdir .ssh &amp;&amp; cd .sshtouch authorized_keysvi authorized_keys // 在这个文件中粘贴进刚刚Winodws下申请的key（在id_rsa.pub文件中）cd ~mkdir hexo.git &amp;&amp; cd hexo.gitgit init --bare (上文中提到hexo.git或者hexo都可以替换成你的网站的名字) 测试一下，如果在git bash中输入ssh git@VPS的IP地址,能够远程登录的话，则表示设置成功了。 创建网站目录并赋予git对网站目录的所有权 123cd /var/wwwmkdir hexochown git:git -R /var/www/hexo (上文中提到hexo都可以替换成你的网站的名字) 配置git hooks 123su gitcd /home/git/hexo.git/hooks # 如果没有hooks目录,就mkdir hooks 自己建一个目录vim post-receive 输入如下内容后保存退出(vim下输入:wq`) 12345678#!/bin/bash -lGIT_REPO=/home/git/hexo.git #git仓库TMP_GIT_CLONE=/tmp/hexoPUBLIC_WWW=/var/www/hexo #网站目录rm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; (上文中提到hexo.git或者hexo都可以替换成你的网站的名字)原理就是从GIT_REPO仓库中把文件拷贝到PUBLIC_WWW目录下发布，中间有个TMP_GIT_CLONE用于保存文件。然后赋予脚本的执行权限 chmod +x post-receive同时把上述的三个路径都用chown git:git -R /路径更改了owner 配置Nginx vim /etc/nginx/conf.d/hexo.conf插入如下代码： 1234567891011121314151617181920212223server &#123; listen 80 ; root /var/www/hexo;//这里可以改成你的网站目录地址，我将网站放在/var/www/hexo server_name example.com www.example.com;//这里输入你的域名或IP地址 access_log /var/log/nginx/hexo_access.log;//这里的log文件也可以根据自己网站名字替换 error_log /var/log/nginx/hexo_error.log;//这里的log文件也可以根据自己网站名字替换 location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123; root /var/www/hexo;//网站目录地址 access_log off; expires 1d; &#125; location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123; root /var/www/hexo;//网站目录地址 access_log off; expires 10m; &#125; location / &#123; root /var/www/hexo;//网站目录地址 if (-f $request_filename) &#123; rewrite ^/(.*)$ /$1 break; &#125; &#125;&#125; 重启Nginxservice nginx restart(如果上述操作git用户搞不定，就切换到root用户su root) 配置hexo配置文件 位于hexo文件夹下，_config.yml,修改deploy选项，改成如下1234567deploy:- type: git repo: ssh://git@VPS的IP地址:/home/git/hexo.git#VPS上对应的git仓库(包含git hooks的地址) branch: master- type: git repo: ssh://git@github.com/hexo.git#github上对应的保存静态文件的仓库 branch: master 接着在hexo文件夹内，按住shift右击，选择在此处打开命令窗口（当然你也可以用cd命令），运行hexo g &amp;&amp; hexo d，如果一切正常，静态文件已经被成功的push到了blog的仓库里，如果出现appears not to be a git repo的错误，删除hexo目录下的.deploy后再次hexo g &amp;&amp; hexo d就可以了。到这里，博客已经完全建好了。 更新博客 使用一款 MarkDown 编辑器写 Blog 。写完后将文件以 *.md的格式保存在本地[网站目录]\source\_posts中。文件编码必须为 UTF-8，这一点仅 Windows 用户需注意。编写完后，只需要在hexo文件夹下执行hexo g &amp;&amp; hexo d，博客即可更新。 备份 由于上面hexo文件夹下执行hexo g &amp;&amp; hexo d执行之后, 会更新github上你的网站目录的信息, 但是markdown文件并没有保存, 保存的是转换成静态文件html, 所以还是需要保存下你的原文件。因此在github上建了一个仓库专门保存博客的原文件。这样更新完博客以后，只要上传一下原文件就可以高枕无忧了。 :) 四、安装中遇到问题 上传操作hexo d报错spawn git ENOENT，添加Git环境变量后可以了 hexo g 报错，安装hexo-delopyer-git后解决。 hexo d 提交到VPS网站目录里的文件并不是单独的public文件夹，检查hexo文件夹发现存在.git这个目录，删除.git文件夹即可（他是隐藏的哦）。 ssh git@ip，被拒绝，是远程端口默认为22端口，而不是我VPS的ssh真正端口。解决方法：在.ssh文件夹下（也就是生成公钥的文件夹）创建config文件，输入如下内容： 12345Host // VPS的IPHostName // VPS的IPUser gitPort // SSH端口IdentityFile ~/.ssh/id_rsa ssh -T git@github.com是否连接上githubgit config --list 查看git config配置 ngix正常配置后，执行 yum install nginx -y。 如果失败，可能是源没有配置，在/etc/yum.repos.d目录下创建一个源配置文件`nginx.repo, 写入如下代码，然后再执行一次。 1234567[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1最后查看版本号，验证完成 `nginx -v` 用yum install git安装Git出现问题：/bin/bash: git: command not found解决（修改安装命令为）：yum install git git-svn git-email git-gui gitk -y ssh配置后，ssh连接验证：ssh: connect to host localhost port 22: Connection refused 12345错误原因：sshd 未安装：yum install openssh-serversshd 未启动：chkconfig sshd on防火墙：chkconfig iptables off(永久性生效，重启后不会复原)端口号没有设置为22(或者设置后没有重启：service sshd restart) 使用hero d报错：ERROR Deployer not found: git解决：记得一定要在 blog 目录里 执行 npm install hexo-deployer-git --save 查看node和npm版本 12node --versionnpm --version warning: LF will be replaced by CRLF | fatal: CRLF would be replaced by LF解决办法：http://blog.csdn.net/feng88724/article/details/11600375http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Tip_Week1-GitLineEndingCharacter/遇到这两个错误，是因为Git的换行符检查功能对于出现一些conflic，可以reset一些，再重新更新 12git reset --hard FETCH_HEADgit pull origin master hexo安装成功，并且正确运行，但是localhost:4000不能访问解决办法：https://yq.aliyun.com/articles/58027遇到这个问题，是因为4000端口被占用了。如果你的电脑上不幸装了福昕阅读，恭喜你！它就是罪魁祸首….胳膊拧不过大腿，对于这种流氓软件，我们别无他法，只能换端口。 :( 12启动hexo s 的时候，用这个命令，换一个端口。hexo s -p 3600 // 随便指定一个端口号就好 添加多个key到gitStep1 添加到github账号： 打开C:\Users\&lt;用户名&gt;\.ssh文件夹，拷贝id_rsa.pub里的内容，在Github账号Settings-&gt;SSH and GPG keys-&gt;New SSH keyStep2 添加到VPS： 在C:\Users\&lt;用户名&gt;\.ssh文件夹下打开Git Bash Here, 执行ssh-copy-id git@vps的IP 运行hexo g &amp;&amp; hexo d后没有触发git hooks解决方案说实话这个问题困扰了我三四天了，之前都是hexo g &amp;&amp; hexo d之后，跑到VPS下的发布目录（www/hexo/）去手动download github上的hexo.git仓库完成发布的。确实不爽，于是翻了好几条网页，终于解决了。方法如下： 检查你的本地public key有没有add 到github账号，并且/home/git/.ssh/authorized_keys里面已经加入了之前Winodws下申请的key hexo文件夹下，_config.yml的配置语句正确如下 1234567deploy:- type: git repo: git@VPS的IP地址:/home/git/hexo.git#VPS上对应的git仓库(包含git hooks的地址) branch: master- type: git repo: git@github.com:&#123;yourname&#125;/hexo.git#github上对应的保存静态文件的仓库 branch: master 千万记得在本地博客路径C:\hexo\下一定要用**Git Bash Here**执行命令，而不是Windows的命令行窗口，否则会一直报“Permission denied, please try again.” 运行ssh -T git@github.com，是否能正常访问github运行hexo g &amp;&amp; hexo d，部署并提交代码到github，同时触发git hooks完成发布过程中会弹出一个OpenSSH的对话框要你输入git的密码，输入完毕，点击ok。搞定！ 本地博客路径C:\hexo\下有个.gitignore 文件，主要用于git status忽略一些列出的文件，但是筒子们有木有发现改了该文件之后，其实并没有作用。百思不得其解之后，搜到某攻略才豁然开朗：只改文件你列出的文件或目录在仓库中，需要执行以下命令手动移除。提交一版之后，整个世界就清净了 :) 1234git rm -rf --cached .git add .git commit -m &quot;xxxxx&quot;git push origin master 为 Next 主题文末添加版权等信息看到别人博客里的版权信息，觉得有点意思，找了很多教程，效果都不是自己想要的。只能借用下Next作者的格式和样式。建立基础的HTML代码定位到本地博客文件夹下的themes\next\layout\_macro\post.swig文件，这个和于layout下的post.swig的区别是前者扶着具体的post-content的生成，而后者是调用前者。然后补充类似comment第三方的模块的脚本。找到post-body所在的标签，并在其后加上如下代码：然后补充类似comment第三方的模块的脚本。找到post-body所在的标签，并在其后加上如下代码： 123456789101112131415161718&lt;div&gt; &#123;# 表示如果不在索引列表中加入后续的HTML代码 #&#125; &#123;% if not is_index %&#125; &lt;ul class=&quot;post-copyright&quot;&gt; &lt;li class=&quot;post-copyright-author&quot;&gt; &lt;strong&gt;本文作者：&lt;/strong&gt;&#123;&#123; theme.author &#125;&#125; &lt;/li&gt; &lt;li class=&quot;post-copyright-link&quot;&gt; &lt;strong&gt;本文链接：&lt;/strong&gt; &lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;post-copyright-license&quot;&gt; &lt;strong&gt;版权声明： &lt;/strong&gt; 本博客所有文章除特别声明外，均采用 &lt;a href=&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 3.0 CN&lt;/a&gt; 许可协议。转载请注明出处！ &lt;/li&gt; &lt;/ul&gt; &#123;% endif %&#125;&lt;/div&gt; 增添样式 定位Next下的source/css/_custom/custom.styl,并在里面添加如下样式代码: 1234567.post-copyright &#123; margin: 2em 0 0; padding: 0.5em 1em; border-left: 3px solid #ff1700; background-color: #f9f9f9; list-style: none;&#125; 五、后记 以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。 https://dynamicer.com/how-to-deploy-hexo-blogs-with-git-hooks-on-vps/ http://tiktoking.github.io/2016/01/26/hexo/ http://blog.csdn.net/hanhailong726188/article/details/46738929 http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html https://arcecho.github.io/2017/04/08/Hexo-Next%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E%E6%A8%A1%E5%9D%97/ 六、编辑工具 因为Hexo是支持Markdown的文件，而Markdown是一种极简的『标记语言』，将文本转为HTML，通常为我大码农所用。 简介好使是关键！以下为一些相关链接，希望对大家有帮助。 Markdown语法 http://ibruce.info/2013/11/26/markdown/ https://maxiang.io/ Markdown编辑器 http://www.csdn.net/article/2014-05-05/2819623 https://maxiang.io/]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>GitHub]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Blood]]></title>
    <url>%2F2017%2F03%2F01%2FOthers%2FFirst-Blood%2F</url>
    <content type="text"><![CDATA[沧海一声啸 缥缈云海间]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>