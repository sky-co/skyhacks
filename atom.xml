<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Practice Makes Perfect</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://skyhacks.org/"/>
  <updated>2018-09-09T16:17:42.530Z</updated>
  <id>http://skyhacks.org/</id>
  
  <author>
    <name>sky_co</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tip_Week3 - Code Diff工具分享</title>
    <link href="http://skyhacks.org/2018/09/09/Arts/Week3/Arts-Tip-Week3-CodeDiffTool/"/>
    <id>http://skyhacks.org/2018/09/09/Arts/Week3/Arts-Tip-Week3-CodeDiffTool/</id>
    <published>2018-09-09T15:48:27.000Z</published>
    <updated>2018-09-09T16:17:42.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr>
<p>Linux下比较常用的代码比较工具是Meld。Meld 是一个可视化的文本差异比较工具，它可以跟多个版本控制系统集成。<br>安装也极其便利：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install update</div><div class="line"></div><div class="line">sudo apt-get install meld</div></pre></td></tr></table></figure></p>
<p>使用：<br>绿色表示没有的，蓝色表示不同的。<br>既然已经知道了不同之处，接下来就是合并了。<br>看到蓝色和绿色颜色区域的“-&gt;”和“&lt;-”箭头没，只需点一下，即可。<br>其他的一些例子和使用方法，可以参考： <a href="http://linux-commands-examples.com/meld" target="_blank" rel="external">http://linux-commands-examples.com/meld</a></p>
<p>更多的一些Linux下的代码比较工具： <a href="https://www.fossmint.com/best-diff-merge-tools-for-linux/" target="_blank" rel="external">https://www.fossmint.com/best-diff-merge-tools-for-linux/</a></p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr>
<p>Windows下主要常用的是Beyond Compare，不过这个软件是付费的。但是相比同类产品还是比较便利。<br>对于Windows下Git的用户来说，使用图形客户端进行差异比较和合并冲突比较直观，因此使用Beyond Compare作为git的比对与合并工具。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开 C:\Users\Administrator.gitconfig 文件，添加如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[diff]</div><div class="line">    tool = bc4</div><div class="line">[difftool &quot;bc4&quot;]</div><div class="line">    cmd = &quot;\&quot;c:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;</div><div class="line">[merge]</div><div class="line">    tool = bc4</div><div class="line">[mergetool &quot;bc4&quot;]</div><div class="line">    cmd = &quot;\&quot;c:/Program Files/Beyond Compare 4/BComp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>(其中bc4什么的根据你安装的/Beyond Compare版本来，以上举例是Beyond Compare4)</p>
<p>也可以通过命令行来设置，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#difftool 配置</div><div class="line">git config --global diff.tool bc4</div><div class="line">git config --global difftool.bc4.cmd &quot;\&quot;c:/program files (x86)/beyond compare 4/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot;&quot;</div><div class="line"></div><div class="line">#mergeftool 配置</div><div class="line">git config --global merge.tool bc4</div><div class="line">git config --global mergetool.bc4.cmd &quot;\&quot;c:/program files (x86)/beyond compare 4/bcomp.exe\&quot; \&quot;$LOCAL\&quot; \&quot;$REMOTE\&quot; \&quot;$BASE\&quot; \&quot;$MERGED\&quot;&quot;</div><div class="line">git config --global mergetool.bc4.trustExitCode true</div></pre></td></tr></table></figure></p>
<p>设置好后，使用命令是 git difftool 而不是之前的 git diff 了。</p>
<p>使用<br>差异比较<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git difftool &lt;filename&gt;</div></pre></td></tr></table></figure></p>
<p>合并冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git mergetool</div></pre></td></tr></table></figure></p>
<p>参考<br><a href="http://skyhacks.org/2017/07/21/Others/UseHexoToBuildBlog/">Windows下使用Beyond Compare作为git的比对与合并工具</a><br><a href="https://blog.csdn.net/mad1989/article/details/16885569" target="_blank" rel="external">Git下的冲突解决</a><br><a href="http://git-scm.com/docs/git-difftool.html" target="_blank" rel="external">git difftool说明文档</a><br><a href="http://www.beyondcompare.cc/jiqiao/wenjianjia-fuzhi.html" target="_blank" rel="external">浅析Beyond Compare复制文件的三种方式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux&quot;&gt;&lt;a href=&quot;#Linux&quot; class=&quot;headerlink&quot; title=&quot;Linux&quot;&gt;&lt;/a&gt;Linux&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;Linux下比较常用的代码比较工具是Meld。Meld 是一个可视化的文本差异比较工具，它可以跟多个版本控
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Tip" scheme="http://skyhacks.org/tags/Tip/"/>
    
      <category term="Git" scheme="http://skyhacks.org/tags/Git/"/>
    
      <category term="Week3" scheme="http://skyhacks.org/tags/Week3/"/>
    
      <category term="Linux" scheme="http://skyhacks.org/tags/Linux/"/>
    
      <category term="Windows" scheme="http://skyhacks.org/tags/Windows/"/>
    
      <category term="Meld" scheme="http://skyhacks.org/tags/Meld/"/>
    
      <category term="Beyond Compare" scheme="http://skyhacks.org/tags/Beyond-Compare/"/>
    
  </entry>
  
  <entry>
    <title>Review_Week3 - 如何像程序员一样思考 — 问题解决的课程</title>
    <link href="http://skyhacks.org/2018/09/07/Arts/Week3/Arts-Review_Week3-HowToThinkLikeProgrammer/"/>
    <id>http://skyhacks.org/2018/09/07/Arts/Week3/Arts-Review_Week3-HowToThinkLikeProgrammer/</id>
    <published>2018-09-06T16:07:10.000Z</published>
    <updated>2018-09-13T15:22:37.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="How-to-think-like-a-programmer-—-lessons-in-problem-solving"><a href="#How-to-think-like-a-programmer-—-lessons-in-problem-solving" class="headerlink" title="How to think like a programmer — lessons in problem solving"></a><a href="https://medium.freecodecamp.org/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2" target="_blank" rel="external">How to think like a programmer — lessons in problem solving</a></h2><p>By Richard Reis</p>
<p>If you’re interested in programming, you may well have seen this quote before:<br>如果你对编程感兴趣，你可能在此之前已经见过以下引用：</p>
<blockquote>
<p>“Everyone in this country should learn to program a computer, because it teaches you to think.” — Steve Jobs<br>“在这个国家的每一个人都应该学习编程，因为它会教会你如何思考。” – 史蒂夫.乔布斯</p>
</blockquote>
<p>You probably also wondered what does it mean, exactly, to think like a programmer? And how do you do it??<br>你可能会想知道像一个程序员一样思考是什么意思？如何才能做到？</p>
<p>Essentially, it’s all about a more effective way for problem solving.<br>实际上，这其实主要是关于如何解决问题的一种高效的方式。</p>
<p>In this post, my goal is to teach you that way.<br>在这篇文章中，我的目的主要是教你们这个方法。</p>
<p>By the end of it, you’ll know exactly what steps to take to be a better problem-solver.<br>到文章的末尾，你们将会知道采取什么步骤可以更高效解决一个问题。</p>
<p>Why is this important?<br>为啥这个这么重要呢？</p>
<p>Problem solving is the meta-skill.<br>解决问题是一种元认知技能。</p>
<p>We all have problems. Big and small. How we deal with them is sometimes, well…pretty random.<br>我们都会遇到问题。大问题和小问题。有时我们如何处理这些问题都是随机的。</p>
<p>Unless you have a system, this is probably how you “solve” problems (which is what I did when I started coding):<br>除非你有一个系统，也就是你如何解决问题（这也是我最初开始编程时候做的）：</p>
<p>Try a solution.<br>尝试一个方法。<br>If that doesn’t work, try another one.<br>如果它不能工作，换一个试试。<br>If that doesn’t work, repeat step 2 until you luck out.<br>如果还不行，重复步骤2直到你很幸运的找到解决方法。</p>
<p>Look, sometimes you luck out. But that is the worst way to solve problems! And it’s a huge, huge waste of time.<br>看吧，有时候你还是很幸运的。但这是一种最差的解决问题的方法！并且，这种方法非常非常的浪费时间。</p>
<p>The best way involves a) having a framework and b) practicing it.<br>最佳的方法应该是 a)有一个框架 b)不断练习。</p>
<p>“Almost all employers prioritize problem-solving skills first.<br>“基本上所有的雇员都优先把解决问题的技能放在第一位。</p>
<p>Problem-solving skills are almost unanimously the most important qualification that employers look for….more than programming languages proficiency, debugging, and system design.<br>解决问题的技能几乎是所有雇主寻找的最重要的特质，相比起程序语言的熟练，代码调试和系统设计来说。</p>
<p>Demonstrating computational thinking or the ability to break down large, complex problems is just as valuable (if not more so) than the baseline technical skills required for a job.” — Hacker Rank (2018 Developer Skills Report)<br>“能被证实的计算能力或者是将一个大的复杂的问题拆分的能力相比起一份工作所需的基本技术技能要更有价值，或者更甚。”— Hacker Rank (2018 Developer Skills Report)</p>
<p>Have a framework<br>拥有一个框架<br>To find the right framework, I followed the advice in Tim Ferriss’ book on learning, “The 4-Hour Chef”.<br>找到一个合适的框架，我遵循 Tim Ferriss的书《The 4-Hour Chef》学习到。</p>
<p>It led me to interview two really impressive people: C. Jordan Ball (ranked 1st or 2nd out of 65,000+ users on Coderbyte), and V. Anton Spraul (author of the book “Think Like a Programmer: An Introduction to Creative Problem Solving”).<br>它指引我面试了两个印象非常深刻的人：C. Jordan Ball（Coderbyte上65，000+的用户中排名数一数二）和 V. Anton Spraul（书《Think Like a Programmer: An Introduction to Creative Problem Solving》的作者）。</p>
<p>I asked them the same questions, and guess what? Their answers were pretty similar!<br>我问了他们相同的问题，你猜怎么着？他们的答案非常相似！</p>
<p>Soon, you too will know them.<br>很快你就会会知道了。</p>
<p>Sidenote: this doesn’t mean they did everything the same way. Everyone is different. You’ll be different. But if you start with principles we all agree are good, you’ll get a lot further a lot quicker.<br>旁注： 这并不意味着他们都是按照同样的方式做事。每个人都不一样。你是独一无二的。但如果你一开始遵循我们认为好的原则，你将会收获更快的成长速度。</p>
<p>“The biggest mistake I see new programmers make is focusing on learning syntax instead of learning how to solve problems.” — V. Anton Spraul<br>“我所见过的新手犯的最大的错误就是过于专注语法的学习，而不是去学习如何解决问题。” — V. Anton Spraul</p>
<p>So, what should you do when you encounter a new problem?<br>所以，当你面对一个新的问题的时候，你会怎么做呢？</p>
<p>Here are the steps:<br>以下是一些步骤：</p>
<ol>
<li>Understand 理解<br>Know exactly what is being asked. Most hard problems are hard because you don’t understand them (hence why this is the first step).<br>搞清楚被问的是什么。大多数难题之所以困难是因为你并没有理解他们（因此，这为什么是第一步）。</li>
</ol>
<p>How to know when you understand a problem? When you can explain it in plain English.<br>如何知道你真正理解了一个问题? 当你可以用言简意赅的解释这个问题的时候。</p>
<p>Do you remember being stuck on a problem, you start explaining it, and you instantly see holes in the logic you didn’t see before?<br>你还记得当年被一个问题困住的时候，你开始试图向别人解释它，突然你就注意到了你之前忽略的逻辑上的漏洞了？</p>
<p>Most programmers know this feeling.<br>大多数程序员都有过这种感觉。</p>
<p>This is why you should write down your problem, doodle a diagram, or tell someone else about it (or thing… some people use a rubber duck).<br>这也是为什么你应该写下你的问题，画一个草图或者尝试把问题讲解给别人听（或者别的招术，一些人用橡皮鸭替代）。</p>
<p>“If you can’t explain something in simple terms, you don’t understand it.” — Richard Feynman<br>“如果你不能言简意赅地把问题解释给别人，你就还没有真正搞明白这个问题。” — Richard Feynman</p>
<ol>
<li>Plan 计划<br>Don’t dive right into solving without a plan (and somehow hope you can muddle your way through). Plan your solution!<br>不要在没有计划的情况下直接解决问题（如果不是，希望你可以蒙混过关）。请为你的解决方案制定计划。</li>
</ol>
<p>Nothing can help you if you can’t write down the exact steps.<br>谁也帮不了你，如果你不把具体的步骤写下来的话。</p>
<p>In programming, this means don’t start hacking straight away. Give your brain time to analyze the problem and process the information.<br>在编程方面，这意味着不要马上开始黑客攻击。给你的大脑一些时间去分析这个问题，处理一些信息。</p>
<p>To get a good plan, answer this question:<br>要制定一个好的计划，请回答这个问题：</p>
<p>“Given input X, what are the steps necessary to return output Y?”<br>“给定的输入 X, 什么是输出Y的必要的步骤?”</p>
<p>Sidenote: Programmers have a great tool to help them with this… Comments!<br>旁注： 程序员有一个非常好的工具帮助他们做到这点…注释！</p>
<ol>
<li>Divide 分解<br>Pay attention. This is the most important step of all.<br>注意，这是最最重要的步骤。</li>
</ol>
<p>Do not try to solve one big problem. You will cry.<br>不要尝试一次解决一个很大的问题。你一定会哭的。</p>
<p>Instead, break it into sub-problems. These sub-problems are much easier to solve.<br>相反，把它拆解成一些子问题。并且这些子问题要更容易解决。</p>
<p>Then, solve each sub-problem one by one. Begin with the simplest. Simplest means you know the answer (or are closer to that answer).<br>然后，一次解决每一个子问题。从最简单的开始。最简单意味着你知道答案（或者接近答案）。</p>
<p>After that, simplest means this sub-problem being solved doesn’t depend on others being solved.<br>除此之外，最简单意味着这个子问题不依赖其他问题的解决。</p>
<p>Once you solved every sub-problem, connect the dots.<br>一旦你解决了所有子问题，把他们串起来。</p>
<p>Connecting all your “sub-solutions” will give you the solution to the original problem. Congratulations!<br>把所有的”子问题的解”串起来后将得到原问题的解。恭喜你！</p>
<p>This technique is a cornerstone of problem-solving. Remember it (read this step again, if you must).<br>这个方法是问题解决的转折。请千万要记住（如果有必要的话，请再读一遍步骤三）。</p>
<p>“If I could teach every beginning programmer one problem-solving skill, it would be the ‘reduce the problem technique.’<br>“如果我要教给每一个刚踏入编程领域的新人一个解决问题的方法的话，那就是缩小问题规模的技术。<br>For example, suppose you’re a new programmer and you’re asked to write a program that reads ten numbers and figures out which number is the third highest. For a brand-new programmer, that can be a tough assignment, even though it only requires basic programming syntax.<br>比如，假设你是一个新手，你被要求写一个程序读取10个数字并找出第三大的数字。对于一个菜鸟来说，这是个难题，尽管它只需要基本的编程语法就可以做到。</p>
<p>If you’re stuck, you should reduce the problem to something simpler. Instead of the third-highest number, what about finding the highest overall? Still too tough? What about finding the largest of just three numbers? Or the larger of two?<br>如果你被卡住了，你应该先把原问题拆分成简单的子问题。如果不是第三大的数字，而是找到所有数字中最大的一个？还会很难么？找到三个数字中最大一个呢？或者两个数字中最大的一个？</p>
<p>Reduce the problem to the point where you know how to solve it and write the solution. Then expand the problem slightly and rewrite the solution to match, and keep going until you are back where you started.” — V. Anton Spraul<br>缩小问题的规模旨在你知道如何解决子问题并写出解。然后逐渐延伸扩展问题并重新解决，如此反复直到你回到最初的起点(解决了原始的问题)。” — V. Anton Spraul</p>
<ol>
<li>Stuck? 卡住了？<br>By now, you’re probably sitting there thinking “Hey Richard… That’s cool and all, but what if I’m stuck and can’t even solve a sub-problem??”<br>到目前为止，你可能会说： “我说Richard…这个方法并不酷，如果我被问题卡住了，甚至不能解决一个子问题咋办？”</li>
</ol>
<p>First off, take a deep breath. Second, that’s fair.<br>首先，深呼吸。然后，当然可以搞定。</p>
<p>Don’t worry though, friend. This happens to everyone!<br>不要慌，我的朋友。每个人都会遇到过此类情况。</p>
<p>The difference is the best programmers/problem-solvers are more curious about bugs/errors than irritated.<br>不同之处在于最好的程序员/问题解决者显得更好奇，而不是恼怒。</p>
<p>In fact, here are three things to try when facing a whammy:<br>实际上，当你遇到难题的时候，这三件事你可以试试：</p>
<p><strong>Debug:</strong> 调试<br>Go step by step through your solution trying to find where you went wrong. Programmers call this debugging (in fact, this is all a debugger does).<br>一步一步的调试你的解直到找到问题所在。程序员称之为debugging（实际上，这都是一个飞蛾给闹的）。</p>
<p>“The art of debugging is figuring out what you really told your program to do rather than what you thought you told it to do.”” — Andrew Singer<br>“调试的艺术是搞清楚你真正告诉程序去执行的动作，而不是你想当然的事情。” — Andrew Singer</p>
<p><strong>Reassess:</strong> 回溯<br>Take a step back. Look at the problem from another perspective. Is there anything that can be abstracted to a more general approach?<br>退一步。从另一个角度来观察问题。有没有什么可以被抽象成更一般的方法？<br>“Sometimes we get so lost in the details of a problem that we overlook general principles that would solve the problem at a more general level. […]<br>“有时候我们会困在问题的细枝末节中，那是因为我们忽略了通用适用于各个级别的解决问题的原则”</p>
<p>The classic example of this, of course, is the summation of a long list of consecutive integers, 1 + 2 + 3 + … + n, which a very young Gauss quickly recognized was simply n(n+1)/2, thus avoiding the effort of having to do the addition.” — C. Jordan Ball<br>经典例子如下，求连续整数的和，1 + 2 + 3 + … + n, 年轻的高斯识别出是  n(n+1)/2, 避免了用于加法的额外运算。” — C. Jordan Ball</p>
<p>Sidenote: Another way of reassessing is starting anew. Delete everything and begin again with fresh eyes. I’m serious. You’ll be dumbfounded at how effective this is.<br>旁注：另一种重新评估的方法是重新开始。删除剩余的所有东西，我是认真的。</p>
<p><strong>Research:</strong> 研究<br>Ahh, good ol’ Google. You read that right. No matter what problem you have, someone has probably solved it. Find that person/ solution. In fact, do this even if you solved the problem! (You can learn a lot from other people’s solutions).<br>啊，好啊，谷歌。你读的是对的。无论你的问题是啥呢么，别人早就解决了。找出那个人或者问题的解。实际上，即使你解决了这个问题，也要这样做！</p>
<p><strong>Caveat:</strong>警告<br>Don’t look for a solution to the big problem. Only look for solutions to sub-problems. Why? Because unless you struggle (even a little bit), you won’t learn anything. If you don’t learn anything, you wasted your time.<br>不要花时间去找规模很大的问题的解。只寻找子问题的解。为啥呢？因为除非你挣扎（尽管可能一丁点儿），否则你不会学到任何东西，如果你不学习，那么就是在浪费时间。</p>
<p>Practice 练习<br>Don’t expect to be great after just one week. If you want to be a good problem-solver, solve a lot of problems!<br>不要期望在仅仅过了一个星期后就会很好。如果你想成为一个问题的解决者，你还需要解决很多问题！</p>
<p>Practice. Practice. Practice. It’ll only be a matter of time before you recognize that “this problem could easily be solved with.”<br>练习，练习，再练习。在你发现“这个问题可以被快速的解决”前只是一个时间的问题。</p>
<p>How to practice? There are options out the wazoo!<br>如何练习？有很多选择！</p>
<p>Chess puzzles, math problems, Sudoku, Go, Monopoly, video-games, cryptokitties, bla… bla… bla….<br>国际象棋，数学问题，数独，围棋，强手游戏，电子游戏，以太猫等等。</p>
<p>In fact, a common pattern amongst successful people is their habit of practicing “micro problem-solving.” For example, Peter Thiel plays chess, and Elon Musk plays video-games.<br>实际上，一个成功人士的通用的模式就是他们训练“解决微问题”。比如Peter Thiel 玩象棋， Elon Musk 打游戏。</p>
<p>“Byron Reeves said ‘If you want to see what business leadership may look like in three to five years, look at what’s happening in online games.’<br>Byron Reeves说：“如果你想看看未来3到5年的商业领导力可能是什么样子，看看网络游戏中发生了什么吧。”</p>
<p>Fast-forward to today. Elon [Musk], Reid [Hoffman], Mark Zuckerberg and many others say that games have been foundational to their success in building their companies.” — Mary Meeker (2017 internet trends report)<br>回到今天。Elon Musk、Reid Hoffman、Mark Zuckerberg，还有其他人说过游戏是他们成功建立公司的基础。“ — Mary Meeker (2017 internet trends report)。<br>Does this mean you should just play video-games? Not at all.<br>这是不是意味着你要打游戏？并非如此。</p>
<p>But what are video-games all about? That’s right, problem-solving!<br>但是什么是电子游戏呢？对了，解决问题！</p>
<p>So, what you should do is find an outlet to practice. Something that allows you to solve many micro-problems (ideally, something you enjoy).<br>所以，你要做的就是找到一个练习的途径。可以能让你解决许多微问题（理想情况下，你喜欢的东西）。</p>
<p>For example, I enjoy coding challenges. Every day, I try to solve at least one challenge (usually on Coderbyte).<br>比如，我喜欢程序挑战赛。每天我都要尝试解决至少一个挑战（通常在Coderbyte上）。</p>
<p>Like I said, all problems share similar patterns.<br>正如我所说的，所有问题都有一个相似的模式。</p>
<p>Conclusion 总结<br>That’s all folks!<br>这些就是全部了！</p>
<p>Now, you know better what it means to “think like a programmer.”<br>现在你对”像程序员一样思考“理解的更深刻一些了。</p>
<p>You also know that problem-solving is an incredible skill to cultivate (the meta-skill).<br>你也知道解决问题是一种难以置信的技能（元技能）。</p>
<p>As if that wasn’t enough, notice how you also know what to do to practice your problem-solving skills!<br>似乎这还不够，你也知道如何去实践解决问题的技巧！</p>
<p>Phew… Pretty cool right?<br>恩，很酷对吧？</p>
<p>Finally, I wish you encounter many problems.<br>最后，我祝愿你们面对很多问题。</p>
<p>You read that right. At least now you know how to solve them! (also, you’ll learn that with every solution, you improve).<br>你阅读这个就对了。至少现在你知道如何解决问题（同时，你会发现在每一个解决方案中，你都会改进）。</p>
<p>“Just when you think you’ve successfully navigated one obstacle, another emerges. But that’s what keeps life interesting.<br>就在你认为你已经成功地越过了一个障碍时，另一个又出现了。但这就是让生活变得有趣的原因。</p>
<p>Life is a process of breaking through these impediments — a series of fortified lines that we must break through.<br>生活是一个突破这些障碍的过程——我们必须突破一系列的强化路线。</p>
<p>Each time, you’ll learn something.<br>每一次你都会学到新东西。</p>
<p>Each time, you’ll develop strength, wisdom, and perspective.<br>每一次，你都将发展力量、智慧和眼界。</p>
<p>Each time, a little more of the competition falls away. Until all that is left is you: the best version of you.” — Ryan Holiday (The Obstacle is the Way)<br>每一次，更多的竞争就会消失。直到剩下的是你：最好的版本的你。”— Ryan Holiday (The Obstacle is the Way)</p>
<p>Now, go solve some problems!<br>现在去解决问题吧！</p>
<p>And best of luck<br>祝你好运</p>
<p>Special thanks to C. Jordan Ball and V. Anton Spraul. All the good advice here came from them.<br>特别感谢C. Jordan Ball 和 V. Anton Spraul。所有的好的建议都出自他俩。</p>
<p>Also, all the programming knowledge I’ve acquired in such a short time wouldn’t have happened without Lambda School. Can’t thank/ recommend them enough.<br>同样，我在这么短的时间内获得的所有编程知识不会在没有Lambda School的情况下发生。不能感谢/推荐他们。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;How-to-think-like-a-programmer-—-lessons-in-problem-solving&quot;&gt;&lt;a href=&quot;#How-to-think-like-a-programmer-—-lessons-in-problem-solving&quot; 
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Review" scheme="http://skyhacks.org/tags/Review/"/>
    
      <category term="Week3" scheme="http://skyhacks.org/tags/Week3/"/>
    
  </entry>
  
  <entry>
    <title>Share_Week3-如何高效的学习</title>
    <link href="http://skyhacks.org/2018/09/06/Arts/Week3/Arts-Share-Week3-HowToStudy/"/>
    <id>http://skyhacks.org/2018/09/06/Arts/Week3/Arts-Share-Week3-HowToStudy/</id>
    <published>2018-09-05T16:22:02.000Z</published>
    <updated>2018-09-13T15:29:37.888Z</updated>
    
    <content type="html"><![CDATA[<p>“万丈高楼平地起，勿在浮沙筑高台.” ― 侯捷</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>第一次见到这句话，应该是四年前读《深入浅出MFC》的时候，不知道这是不是侯捷先生的原创。<br>勿在浮沙筑高台。<br>问题一：学习是件逆人性的事，现在的生活工作节奏很快，时间都是碎片的，很容易就给自己一个借口：“没时间，太累了，想放松一下…”诸如此类的借口可以找一大堆。说实话就是“懒”。<br>问题二：书买了不少，也看了很多。大多数情况下，收效甚微。</p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>这几天耗叔的专栏开始讲如何学习的主题，对此我也是很有兴趣。因为我想知道，在同样公平的时间下，为啥别人通过努力站在一个如今我只能仰望的角度。作为一个菜鸟，大神的学习和努力的过程总是充满神秘。这篇文章也算是对这个系列的总结吧。</p>
<p>问题一解答：<br>在信息化的社会，像几十年前父辈一样，泡杯茶，端坐书桌前，摊开一本书细细品读个几个小时的生活已经一去不复返。现在生活工作节奏很快，如何利用好碎片时间提升自己，才可以在工作和生活中脱颖而出，至少比昨天的自己更进步一点。</p>
<p>问题二解答：<br>学习不是努力读更多的书，盲目追求阅读的速度和数量，这会让人产生低层次的勤奋和成长的感觉，这只是在使蛮力。</p>
<h2 id="学习的分类"><a href="#学习的分类" class="headerlink" title="学习的分类"></a>学习的分类</h2><p>人的学习分为被动学习和主动学习两种。<br>被动学习：如听讲、阅读、试听、演示，学习内容的平均留存率为5%、10%、20和30%。<br>主动学习：如通过讨论、实践、教授给他人，会将原来被动学习的内容留存率从5%提升到50%、75%和90%。</p>
<p>人的记忆都是遵循艾宾浩斯遗忘曲线的，不过艾宾浩斯遗忘曲线对我们在实践学习中能起到的用处就是告诉我们以下2点:<br>1、我们的知识的遗忘是由规律的<br>2、遗忘的速度是先快后慢；<br>观察曲线，你会发现,学得的知识在一天后，如不抓紧复习,就只剩下原来的25%。随着时间的推移,遗忘的速度减慢，遗忘的数量也就减少，得一个多月后就几乎忘得差不多了;而刚刚学习过的知识，记忆内容在80%-100%。这个遗忘规律告诉我们，要想让所学到的知识内容保持80%以上的长期记忆，只有不断地重复记忆，因为每复习一次就是记忆保持在刚刚学过的状态80%以上，多次强化后，短时记忆会形成长时记忆，就不会再忘记了。<br>通过对知识内容的多次强化复习，记忆的内容会长期保持在80%以上。</p>
<h2 id="如何才能正确高效地学习"><a href="#如何才能正确高效地学习" class="headerlink" title="如何才能正确高效地学习"></a>如何才能正确高效地学习</h2><p><strong>端正的学习态度和正确的学习观念</strong><br>学习不仅仅是为了找到答案，而是为了找到方法<br>学习不仅仅是为了知道，而更是我饿了思考和理解<br>学习不仅仅是为了开拓眼界，而更是为了找到自己的未知，为了了解自己<br>学习不仅仅是为了成长，而更是为了改变自己，改变自己的思考方式，改变自己的思维方式，改变自己与生俱来的那些垃圾和低效的算法</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习三个步骤</p>
<blockquote>
<p>知识采集<br>高质量的信息源是非常重要的，获取信息源头、破解表面新的内在本质、多方数据影子呢个，是这个步骤的关键。<br>知识缝合<br>所谓知识缝合就是把信息组织起来，成为结构体的知识。这里，连接记忆，逻辑推理，知识梳理是很重要的三部分。把知识炼成地图，将自己的理解反述出来。不断地反思和思辨，与不同年龄段的人讨论。<br>技能转换<br>通过举一反三、实践和练习，以及传授教导，把知识会转化成自己的技能。这种技能可以让你比进入更高的阶层。</p>
</blockquote>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ol>
<li><a href="https://www.amazon.cn/dp/B005DSK4W8/ref=sr_1_1?ie=UTF8&amp;qid=1536421899&amp;sr=8-1&amp;keywords=%E6%9A%97%E6%97%B6%E9%97%B4" target="_blank" rel="external">暗时间</a></li>
<li><a href="https://www.amazon.cn/dp/B00H2EBDM6/ref=sr_1_2?ie=UTF8&amp;qid=1536421899&amp;sr=8-2&amp;keywords=%E6%9A%97%E6%97%B6%E9%97%B4" target="_blank" rel="external">如何高效学习:1年完成麻省理工4年33门课程的整体性学习法</a></li>
<li><a href="https://www.amazon.cn/dp/B00FF1Y8IE/ref=sr_1_1?ie=UTF8&amp;qid=1536506241&amp;sr=8-1&amp;keywords=%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E4%BD%9C%E6%9C%8B%E5%8F%8B" target="_blank" rel="external">把时间当作朋友</a></li>
</ol>
<p>以下是文章相关链接：<br><a href="https://time.geekbang.org/column/article/14271" target="_blank" rel="external">高效学习：端正学习态度</a><br><a href="https://time.geekbang.org/column/article/14380" target="_blank" rel="external">高效学习：如何学习和阅读代码</a><br><a href="https://time.geekbang.org/column/article/14360" target="_blank" rel="external">高效学习：深度，归纳和坚持实践</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“万丈高楼平地起，勿在浮沙筑高台.” ― 侯捷&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;第一次见到这句话，应该是四年前读《深入浅出MFC》的时候，不知道这是不是侯捷先
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Share" scheme="http://skyhacks.org/tags/Share/"/>
    
      <category term="Week3" scheme="http://skyhacks.org/tags/Week3/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 766. Toeplitz Matrix</title>
    <link href="http://skyhacks.org/2018/09/05/LeetCode/LeetCode-ToeplitzMatrix/"/>
    <id>http://skyhacks.org/2018/09/05/LeetCode/LeetCode-ToeplitzMatrix/</id>
    <published>2018-09-05T01:40:59.000Z</published>
    <updated>2018-09-13T15:31:41.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/toeplitz-matrix" target="_blank" rel="external">题目描述</a>：</h2><p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.<br>Now given an M x N matrix, return True if and only if the matrix is Toeplitz.</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">matrix = [</div><div class="line">  [1,2,3,4],</div><div class="line">  [5,1,2,3],</div><div class="line">  [9,5,1,2]</div><div class="line">]</div><div class="line">Output: True</div><div class="line">Explanation:</div><div class="line">In the above grid, the diagonals are:</div><div class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;.</div><div class="line">In each diagonal all elements are the same, so the answer is True.</div></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">matrix = [</div><div class="line">  [1,2],</div><div class="line">  [2,2]</div><div class="line">]</div><div class="line">Output: False</div><div class="line">Explanation:</div><div class="line">The diagonal &quot;[1, 2]&quot; has different elements.</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1. matrix will be a 2D array of integers.</div><div class="line">2. matrix will have a number of rows and columns in range [1, 20].</div><div class="line">3. matrix[i][j] will be integers in range [0, 99].</div></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>Toeplitz（托普利茨）矩阵是指各条从左上到右下对角线元素均相等的矩阵。<br>给定M x N矩阵，判断是否为Toeplitz矩阵。</p>
<h3 id="解题思路1："><a href="#解题思路1：" class="headerlink" title="解题思路1："></a>解题思路1：</h3><hr>
<p>遍历除了最后一行和最后一列的元素，查看每个元素对角线上的下一个元素是否相等。<br>参考LeetCode Discuss：<br><a href="https://leetcode.com/problems/toeplitz-matrix/discuss/113417/Java-solution-4-liner" target="_blank" rel="external">https://leetcode.com/problems/toeplitz-matrix/discuss/113417/Java-solution-4-liner</a>.</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size() - <span class="number">1</span>; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].size() - <span class="number">1</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[i][j] != matrix[i + <span class="number">1</span>][j + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="解题思路2："><a href="#解题思路2：" class="headerlink" title="解题思路2："></a>解题思路2：</h3><hr>
<p>除了逐个遍历元素以外，观察可得，只需要考虑第一行和第一列的元素（除第一行最后一个元素和第一列最后一个元素以外）是否存在对角线上元素与之相等。</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> row = matrix.size();</div><div class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; row - <span class="number">1</span>; idx++) &#123;</div><div class="line">            <span class="keyword">int</span> i = idx;</div><div class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">            <span class="keyword">while</span>(i &lt; row &amp;&amp; j &lt; col) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[idx][<span class="number">0</span>] != matrix[i][j]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; col - <span class="number">1</span>; idx++) &#123;</div><div class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> j = idx;</div><div class="line">            <span class="keyword">while</span>(i &lt; row &amp;&amp; j &lt; col) &#123;</div><div class="line">                <span class="keyword">if</span> (matrix[<span class="number">0</span>][idx] != matrix[i][j]) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                &#125;</div><div class="line">                i++;</div><div class="line">                j++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/toeplitz-matrix&quot; target=&quot;_blank&quot;
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 867. Transpose Matrix</title>
    <link href="http://skyhacks.org/2018/08/30/LeetCode/LeetCode-TransposeMatrix/"/>
    <id>http://skyhacks.org/2018/08/30/LeetCode/LeetCode-TransposeMatrix/</id>
    <published>2018-08-30T01:40:59.000Z</published>
    <updated>2018-09-13T15:31:28.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/transpose-matrix" target="_blank" rel="external">题目描述</a>：</h2><p>Given a matrix A, return the transpose of A.<br>The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix.</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</div><div class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</div></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [[1,2,3],[4,5,6]]</div><div class="line">Output: [[1,4],[2,5],[3,6]]</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1 &lt;= A.length &lt;= 1000</div><div class="line">1 &lt;= A[0].length &lt;= 1000</div></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>把一个矩阵按照主对角线，翻转行列的数值。<br>测试样例见题目描述</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>其实就是讲远矩阵的行列颠倒过来，按主对角线翻转就是元素的行列索引值对调。</p>
<hr>
<p>参考LeetCode Discuss：<br><a href="https://leetcode.com/problems/transpose-matrix/discuss/146797/C++JavaPython-Easy-Understood" target="_blank" rel="external">https://leetcode.com/problems/transpose-matrix/discuss/146797/C++JavaPython-Easy-Understood</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vRes;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == A.size()) <span class="keyword">return</span> vRes;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> row = A.size();</div><div class="line">        <span class="keyword">int</span> col = A[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> colIdx = <span class="number">0</span>; colIdx &lt; col; colIdx++) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> rowIdx = <span class="number">0</span>; rowIdx &lt; row; rowIdx++) &#123;</div><div class="line">                v.push_back(A[rowIdx][colIdx]);</div><div class="line">            &#125;</div><div class="line">            vRes.push_back(v);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> vRes;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/transpose-matrix&quot; target=&quot;_blank
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Share_Week2-如何正确高效地问对问题</title>
    <link href="http://skyhacks.org/2018/08/30/Arts/Week2/Arts-Share-Week2-HowToAskQuestions/"/>
    <id>http://skyhacks.org/2018/08/30/Arts/Week2/Arts-Share-Week2-HowToAskQuestions/</id>
    <published>2018-08-29T16:22:02.000Z</published>
    <updated>2018-09-02T16:34:01.810Z</updated>
    
    <content type="html"><![CDATA[<p>“Judge a man by his questions rather than by his answers.” ― Voltaire</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>可能大家看到这个标题觉得很不以为然，不就是问问题么？谁不会啊！可你有想过高效正确的问对问题么？耗叔曾经写过一篇文章<a href="https://coolshell.cn/articles/10804.html" target="_blank" rel="external">X-Y Problem</a>。今天选择聊这个话题也是因为最近接手的项目周期比较赶，文档缺失，但是又需要你能快速把握整个系统，所以就需要跟很多与这个项目有关联的人打交道，这个就挺考验提问的技巧。<br>言归正传，下面就开始谈谈怎么高效地问对问题。</p>
<h2 id="为什么要问问题"><a href="#为什么要问问题" class="headerlink" title="为什么要问问题"></a>为什么要问问题</h2><p>这个好像是废话，因为不懂，因为想知道为什么，好了下一个…</p>
<h2 id="你想要的是什么"><a href="#你想要的是什么" class="headerlink" title="你想要的是什么"></a>你想要的是什么</h2><p>当你在想要问问题前，你必须先要知道你到底想要问的是什么，并且把一个问题放到一个合适的上下文环境中，这样才有助于回答者可以快速理解你的问题点并给出回答。</p>
<h2 id="如何才能正确高效地问对问题"><a href="#如何才能正确高效地问对问题" class="headerlink" title="如何才能正确高效地问对问题"></a>如何才能正确高效地问对问题</h2><p>让我们先从一个例子开始：</p>
<blockquote>
<p>你: “老板，我需要怎样做才能得到提升啊?”<br>老板:“你必须按期完成我们需要的目标！”<br>呵呵，这不是开玩笑。老板的回答的确回答了你的问题, 但是可能并不是你所期望的回答。你只能疑惑地离开，想着老板是不是对你的工作和进步不太在意?</p>
</blockquote>
<p>让我们换另一种方法:</p>
<blockquote>
<p>你: “老板, 假设我按期完成了目标，如果我想要得到提升，那么在其他方面我还需要做什么？”<br>老板: “呃，你也确实应该涉及决策部门了，而不仅仅是完成任务。”</p>
</blockquote>
<p>正如你看到的，你的措辞对你得到的答复影响很大。所以，聪明的问问题方法是：把对方会显而易见的回答变成自己的陈述包含在你问的问题中。让别人顺着你“设计好的圈套”回答你想知道的答案。这就是问问题的技巧。</p>
<p><strong>问问题的场合</strong><br>不同的场合和形势下，你问问题所用的方法也会不同。不同场合需要换位思考，别人是否方便回答你的问题，比如以下几个场合就不是很方便：</p>
<ol>
<li>在别人打电话的时候；</li>
<li>—非常忙碌的时候；</li>
<li>正在休息的时候；</li>
<li>开会的时候；</li>
<li>会见客人的时候；</li>
<li>处理私人问题的时候；</li>
</ol>
<p>当然首先语言上一定要注意礼貌问题，打招呼时先说你好。这样不会引起别人的反感。<br>其次，且不说别人给出的答案是否100%正确，当别人花时间给你解释和回答了问题，结束时候记得要感谢别人，礼尚往来。</p>
<p><strong>问可供选择的问题</strong><br>这个技巧其实是很多做销售的人惯用的技巧。不要问只有“是”与“否”两个答案的问题，除非你十分肯定答案是“是”。<br>例如：不要问：“你想买双门轿车吗?”；要问：“你想要双门还是四门轿车?”<br>如果你用后面这种二选一的问题，回答问题的人就无法拒绝你。</p>
<p><strong>要问具体的内容</strong><br>不要问太泛的问题，因为这些问题的回答往往也是可有可无，你得不到有价值的答案。所以，尽量问你所关心的具体内容，有针对性的去问问题，每个问题最好都集中针对某个具体的点。<br>同时，对于问题的描述一定要言简意赅，最简单概括的语言把你的问题说出来，让人家听懂，这样也给对方一个思考的时间。</p>
<p><strong>学会聆听</strong></p>
<blockquote>
<p>Silence is golden.<br>问问题是一个相互沟通的过程，成为一个好的听众也很重要。尤其是别人正在说话或者回答问题时候，贸然的打断显得很不礼貌，同时也可能打乱别人的逻辑。</p>
</blockquote>
<p><strong>换位思考问自己</strong><br>花一秒钟的时间思考一下你将如何回答你将要问的问题，换位思考，假如你是对方，你会怎么回答这个问题？ 这个问题的描述是否准备，措辞是否得当？ 如果不合适，请考虑换个措辞或者修改问题的描述。<br>国外有个很著名的<a href="http://www.ituring.com.cn/article/195788" target="_blank" rel="external">橡皮鸭子解决问题法</a>, 大意就是提交问题的人应该在提问前多花点时间研究一下他们的问题，整理思路，对着一只橡皮鸭提出的问题。在提问的过程中思考，自己的问题是否是自己想要的问的东西？在这个过程中，说不定不用找别人提问，自己就有了答案。</p>
<p><strong>确认是否听懂了回答</strong><br>如果问题很重要，你必须反复确认你是否听明白了回答，你可以用下面的办法确认你听到的回答：</p>
<ol>
<li><p>重复<br>“哦，你的意思是说如果X和Y发生的话，Z就会发生。对吗？”</p>
</li>
<li><p>装不懂：<br>“好的，你可以稍微再解释一下吗（我只想确定我是否听明白了）？”</p>
</li>
<li><p>换做自己的话说：<br>“嗯，不错。如果X和Y发生的话，我应该期望Z会发生，因为…”<br>使用和回答者不同的措辞，并把你认为的话添加在后面。即使你所认为的事情可能并没有在会话中出现，但是，加上你说的话会使这场谈话更有价值。</p>
</li>
</ol>
<p><strong>训练</strong><br>在问别人前，先按照以下方法向自己发问，通过平时稍加训练，有助于你成为更好的思考者。</p>
<blockquote>
<ol>
<li>Focus: What specifically do I want to know? What information am I missing? Is this more than a simple YES or NO question? Am I going for deeper knowledge?</li>
<li>Purpose: Why am I asking this? Do I want to gather facts or opinions? Do I need simple clarification? Do I want to offer a different perspective?</li>
<li>Intent: How do I want people to respond? Do I want the answer to be of help to others? Am I asking to start an argument or open a discussion? Is the question superficial and not really useful or important? Am I asking out of frustration or curiosity? Do I really care about the answer? Am I willing to show respect/deference to the person I’m asking?</li>
<li>Framing: Am I using easily understandable terms and wording? Is my question neutral or does it contain bias or opinion? Is it too long or too short? Does it contain the focus of what I want to know? Does the question focus on only one thing? Is it muddled with other inquiries that don’t belong?</li>
<li>Follow-up: Do I have any more specific questions to add? Will the person I’m asking be available for other questions if need be? If I still don’t have the answer I need, what’s my plan? What can I do if I still don’t understand?</li>
</ol>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>问问题也是一门艺术，其中有很多技巧，上面只是几个关键的点。在你下次问问题的时候，不妨换一个问法，相信你会有新的体验和收获。</p>
<p>以下是文章相关链接：</p>
<ol>
<li><a href="https://www.douban.com/group/topic/8100581/" target="_blank" rel="external">https://www.douban.com/group/topic/8100581/</a></li>
<li><a href="https://jingyan.baidu.com/article/fdbd4277a5d7e8b89f3f485a.html" target="_blank" rel="external">https://jingyan.baidu.com/article/fdbd4277a5d7e8b89f3f485a.html</a></li>
<li><a href="https://www.entrepreneur.com/article/254264" target="_blank" rel="external">https://www.entrepreneur.com/article/254264</a></li>
<li><a href="https://hbr.org/2009/05/real-leaders-ask.html" target="_blank" rel="external">https://hbr.org/2009/05/real-leaders-ask.html</a></li>
<li><a href="https://www.lifehack.org/articles/communication/how-amazingly-good-asking-questions.html" target="_blank" rel="external">https://www.lifehack.org/articles/communication/how-amazingly-good-asking-questions.html</a></li>
<li><a href="https://www.inc.com/rhett-power/great-leaders-ask-the-right-questions.html" target="_blank" rel="external">https://www.inc.com/rhett-power/great-leaders-ask-the-right-questions.html</a></li>
<li><a href="https://www.coachingforchange.com/pub10.html" target="_blank" rel="external">https://www.coachingforchange.com/pub10.html</a></li>
<li><a href="https://medium.com/personal-growth/are-you-asking-the-right-questions-48c7de027de" target="_blank" rel="external">https://medium.com/personal-growth/are-you-asking-the-right-questions-48c7de027de</a></li>
<li><a href="https://globaldigitalcitizen.org/ask-good-questions-infographic" target="_blank" rel="external">https://globaldigitalcitizen.org/ask-good-questions-infographic</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“Judge a man by his questions rather than by his answers.” ― Voltaire&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Share" scheme="http://skyhacks.org/tags/Share/"/>
    
      <category term="Week2" scheme="http://skyhacks.org/tags/Week2/"/>
    
  </entry>
  
  <entry>
    <title>Tip_Week2 - 使用Hexo和GitHub搭建博客，出现hexo -d报错解决方案</title>
    <link href="http://skyhacks.org/2018/08/29/Arts/Week2/Arts-Tip-Week2-HexoDeployGithub/"/>
    <id>http://skyhacks.org/2018/08/29/Arts/Week2/Arts-Tip-Week2-HexoDeployGithub/</id>
    <published>2018-08-29T15:48:27.000Z</published>
    <updated>2018-09-02T16:28:31.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><hr>
<p>之前按照网上的教程，自己用Hexo搭建了一个博客。为了偷懒，写了一个hook的脚本，实现一行命令提交并且更新博客内容，见文稿:<a href="http://skyhacks.org/2017/07/21/Others/UseHexoToBuildBlog/">Hexo环境搭建个人博客</a>。<br>但是之前Hexo的部署方案有问题，隔了一段时间以后发现没办法提交Github和部署到自己的博客网站了。</p>
<h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><hr>
<p>解决方法是修改根目录下的_config.yml配置<br>下面是<a href="https://hexo.io/zh-cn/docs/deployment.html#Git" target="_blank" rel="external">文档</a> 中的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">type: git</div><div class="line">repo: &lt;repository url&gt;</div><div class="line">branch: [branch]</div><div class="line">message: [message]</div></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo: git@VPS的IP地址:/home/git/hexo.git#VPS上对应的git仓库(包含git hooks的地址)</div><div class="line">  branch: master</div><div class="line">- type: git</div><div class="line">  repo: git@github.com:&#123;yourname&#125;/hexo.git#github上对应的保存静态文件的仓库</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<h2 id="三、后记"><a href="#三、后记" class="headerlink" title="三、后记"></a>三、后记</h2><hr>
<p>以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。</p>
<ol>
<li><a href="https://www.zhihu.com/question/38219432" target="_blank" rel="external">https://www.zhihu.com/question/38219432</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;之前按照网上的教程，自己用Hexo搭建了一个博客。为了偷懒，写了一个hook的脚本，实现一行命令提交并且更新博客内
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Hexo" scheme="http://skyhacks.org/tags/Hexo/"/>
    
      <category term="Tip" scheme="http://skyhacks.org/tags/Tip/"/>
    
      <category term="Git" scheme="http://skyhacks.org/tags/Git/"/>
    
      <category term="Week2" scheme="http://skyhacks.org/tags/Week2/"/>
    
  </entry>
  
  <entry>
    <title>Review_Week2 - Remote Code Execution on a Facebook server</title>
    <link href="http://skyhacks.org/2018/08/25/Arts/Week2/Arts-Review_Week2-RemoteCodeExecution/"/>
    <id>http://skyhacks.org/2018/08/25/Arts/Week2/Arts-Review_Week2-RemoteCodeExecution/</id>
    <published>2018-08-24T16:07:10.000Z</published>
    <updated>2018-08-28T15:51:45.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Remote-Code-Execution-on-a-Facebook-server"><a href="#Remote-Code-Execution-on-a-Facebook-server" class="headerlink" title="Remote Code Execution on a Facebook server"></a><a href="https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/" target="_blank" rel="external">Remote Code Execution on a Facebook server</a></h2><p>By Blaklis</p>
<p>I regularly search for vulnerabilities on big services that allow it and have a Bug Bounty program. Here is my first paper which covers a vulnerability I discovered on one of Facebook’s servers.<br>我经常在大型服务器中需找漏洞，并且有个bug赏金计划。这个是我的第一篇文章，其中介绍了一个我在一台Facebook的服务器上发现的漏洞。</p>
<p>While scanning an IP range that belongs to Facebook (199.201.65.0/24), I found a Sentry service hosted on 199.201.65.36, with the hostname sentryagreements.thefacebook.com. Sentry is a log collection web application, written in Python with the Django framework.<br>当我在扫描属于Facebook（199.201.65.0/24）的IP范围时，我在199.201.65.36中找到了一个岗哨服务，主机名叫sentryagreements.thefacebook.com。岗哨是一个日子收集的网络程序，基于Django framework使用python开发的。</p>
<p>While I was looking at the application, some stacktraces regularly popped on the page, for an unknown reason. The application seemed to be unstable regarding the user password reset feature, which occasionally crashed. Django debug mode was not turned off, which consequently prints the whole environment when a stacktrace occurs. However, Django snips critical information (passwords, secrets, key…) in those stacktraces, therefore avoiding a massive information leakage.<br>正当我在看这个应用的时候，不知道什么原因，一些stacktraces不时的在页面上弹出。关于用户密码重置这个特性来看，这个应用看起来很不稳定，不时的崩溃。Django debug mode并没有关闭， 结果是当stacktrace发生时，日志打印出整个环境信息。无论如何，Django抓取了一些诸如密码和秘密，还有密钥等的关键的信息</p>
<p>However, by looking at the stacktrace a little more closely, some env keys were interesting :<br>无论如何，稍微仔细看了下stacktrace，一些环境的key值非常有意思：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">The SESSION_COOKIE_NAME is sentrysid</div><div class="line">SESSION_COOKIE_NAME是岗哨服务</div><div class="line">The SESSION_SERIALIZER is django.contrib.sessions.serializers.PickleSerializer</div><div class="line">SESSION_SERIALIZER是django.contrib.sessions.serializers.PickleSerializer</div><div class="line">The SESSION_ENGINE is django.contrib.sessions.backends.signed_cookies</div><div class="line">SESSION_ENGINE是django.contrib.sessions.backends.signed_cookies</div><div class="line">The SENTRY_OPTIONS key that contains some Sentry configuration in a list.</div><div class="line">SENTRY_OPTIONS键值包含了一些岗哨的在一个列表中的配置信息。</div></pre></td></tr></table></figure></p>
<p>Pickle is a binary protocol for (un)serializing Python object structures, such as classes and methods in them. A comprehensive article that explains what Pickle is and its security implications is available here :<br><a href="https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/" target="_blank" rel="external">https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/</a><br>Pickle是一个用于python对象数据结构序列化和反序列化的协议，比如其中的类和方法。一篇关于Pickle和它的安全实现的文章地址如下：<br><a href="https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/" target="_blank" rel="external">https://www.balda.ch/posts/2013/Jun/23/python-web-frameworks-pickle/</a></p>
<p>If we were able to forge our own session that contains arbitrary pickle content, we could execute commands on the system. However, the SECRET_KEY that is used by Django for signing session cookies is not available in the stacktrace. However, the SENTRY_OPTIONS list contains a key named system.secret-key, that is not snipped. Quoting the Sentry documentation, system.secret-key is “a secret key used for session signing. If this becomes compromised it’s important to regenerate it as otherwise its much easier to hijack user sessions.“; wow, it looks like it’s a sort of Django SECRET-KEY override!<br>如果我们可以在我们的session里包含一些任意的pickle的内容，我们就可以执行系统的命令。无论如何，stacktrace里的被Django用于单独签名的session cookiesSECRET_KEY是无效的的。无论如何，SENTRY_OPTIONS的键值里包含system.secret-key，这是逃不掉的。引用Sentry的文档，system.secret-key是用于session 签名的一个的密钥。如果这一问题被破坏，那么重新生成它是很重要的，否则就更容易劫持用户会话。wow, 这看起来就像 Django 的某个SECRET-KEY被覆写了。</p>
<p>As we have everything to forge our own cookies with arbitrary pickle content, I wrote a little script that adds a payload into my own sentrysid cookie. Here it is :<br>我们想把一切东西都融合到我们包含arbitrary pickle的cookies里，我写了一个小脚本用于添加负载到我的sentrysid cookie里。如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line">import django.core.signing, django.contrib.sessions.serializers</div><div class="line">from django.http import HttpResponse</div><div class="line">import cPickle</div><div class="line">import os</div><div class="line"></div><div class="line">SECRET_KEY=&apos;[RETRIEVEDKEY]&apos;</div><div class="line">#Initial cookie I had on sentry when trying to reset a password</div><div class="line">cookie=&apos;gAJ9cQFYCgAAAHRlc3Rjb29raWVxAlgGAAAAd29ya2VkcQNzLg:1fjsBy:FdZ8oz3sQBnx2TPyncNt0LoyiAw&apos;</div><div class="line">newContent =  django.core.signing.loads(cookie,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=&apos;django.contrib.sessions.backends.signed_cookies&apos;)</div><div class="line">class PickleRce(object):</div><div class="line">    def __reduce__(self):</div><div class="line">        return (os.system,(&quot;sleep 30&quot;,))</div><div class="line">newContent[&apos;testcookie&apos;] = PickleRce()</div><div class="line"></div><div class="line">print django.core.signing.dumps(newContent,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=&apos;django.contrib.sessions.backends.signed_cookies&apos;,compress=True)</div></pre></td></tr></table></figure></p>
<p>This code is a simple proof of concept; it takes the content of an existing sentrysid cookie, and replaces its content with an arbitrary object that will run a os.system(“sleep 30”) when unserialized.<br>这个代码是对概念的简单的证实。它获取了现存的sentrysid的cookie的内容，然后一个任意的对象替换了其中的内容，当反序列化的时候就会执行os.system(“sleep 30”)。</p>
<p>When using this cookie, the page actually takes an additional 30 seconds to load, which confirms the presence of the flaw.<br>当使用这个cookie的时候，页面就会自然等待30秒的去加载，以上证实了缺陷的存在。</p>
<p>Facebook acknowledged the vulnerability, took down the system until the flaw was patched, and then notified me about the patch being in place.<br>Facebook知道了这个漏洞，关闭了系统直到缺陷被打上补丁。然后通知我补丁已经就位。</p>
<p>Here is the disclosure timeline, which also demonstrates that Facebook security staff is reactive:<br>下面是批露的一些时间线，更证实了Facebook安全人员是被动的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">30.07.2018 00:00 CEST : initial disclosure with every details.</div><div class="line">30.07.2018 00:00 CEST : 初始化泄漏所有的细节.</div><div class="line">30.07.2018 15:25 CEST : triaged and system takedown.</div><div class="line">30.07.2018 15:25 CEST : 系统修复和可拆卸.</div><div class="line">09.08.2018 18:10 CEST : patch in place.</div><div class="line">09.08.2018 18:10 CEST : 补丁就位.</div><div class="line">09.08.2018 20:10 CEST : a 5000$ bounty is awarded – the server was in a separate VLAN with no users’ specific data.</div><div class="line">09.08.2018 20:10 CEST : 一个5000美元的赏金被授予——服务器位于一个单独的VLAN中，没有用户的特定数据.</div></pre></td></tr></table></figure></p>
<p>Thanks for reading!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Remote-Code-Execution-on-a-Facebook-server&quot;&gt;&lt;a href=&quot;#Remote-Code-Execution-on-a-Facebook-server&quot; class=&quot;headerlink&quot; title=&quot;Remote C
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Review" scheme="http://skyhacks.org/tags/Review/"/>
    
      <category term="Week2" scheme="http://skyhacks.org/tags/Week2/"/>
    
  </entry>
  
  <entry>
    <title>Share_Week1-不做伪工作者</title>
    <link href="http://skyhacks.org/2018/08/21/Arts/Week1/Arts-Share-Week1-HowToWork/"/>
    <id>http://skyhacks.org/2018/08/21/Arts/Week1/Arts-Share-Week1-HowToWork/</id>
    <published>2018-08-20T16:22:02.000Z</published>
    <updated>2018-08-24T15:34:47.802Z</updated>
    
    <content type="html"><![CDATA[<p>今天听了《吴军硅谷来信-001封信|不做伪工作者》，感触颇多，稍微整理记录一下，分享出来。</p>
<h2 id="伪工作者的定义"><a href="#伪工作者的定义" class="headerlink" title="伪工作者的定义"></a>伪工作者的定义</h2><p>伪工作者（Pseudo Worker），来源于Google。指代一些每天应付事务性的工作的人。这些人虽然每天把自己搞得很忙，但是他们所作的工作（也被称为伪工作）并不会对公司的发展产生什么重大效果，俗称碌碌无为。</p>
<h2 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h2><ol>
<li>当员工对自己在公司的境遇不满，他们会消极对待工作，不自觉成为一个伪工作者。</li>
<li>一些员工总是挑些简单的事情而不是有挑战的工作去做，工作状态看上去饱和，但是实际上是在坑自己，伪工作做的越多，个人进步就越慢，甚至倒退。</li>
</ol>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>对于管理者</strong></p>
<ol>
<li>管理者要让员工站在“做什么事情能让公司最大收益”的基础上去工作。<br>只有这样才能让员工开始动脑筋在做不完的工作中找到那些对公司最有帮助的时期去做，而不是就简单应付老板安排的工作并交差。</li>
<li>管理者要让员工明白，他们积极工作（而不是消极完成任务），最大的受益方是他们自己。</li>
</ol>
<p><strong>对于员工自身</strong><br>一个人追求的不是完成了百分之几，或者百分之几十的工作，而是做完了那几件重要的事情。一个聪明的员工，应该善于找到最重要的工作，并且优先完成它们，产生最大化收益。而这个，恰恰是每一个新员工说欠缺的。</p>
<p>宽泛的讲，其实很多人在生活中，也是不断把时间浪费在那些可做可不做的事情上，然后收效甚微。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>工作很多，永远也不可能做不完。这叫要求我们要会甄别什么才是最重要的工作，可以借鉴80-20法则，往往20%的工作才是最有产出的工作，也最应该我们花时间花精力把它做好，只有这样才能称得上Smart Work。当然，找对做事情的方法后，还要做好对时间的把控。不然只是在做重复性的劳动，这样的情况，在优胜劣汰的自然界，是迟早要被淘汰的。</p>
<blockquote>
<p><strong>吴军的观点：</strong>在面对总也做不完的工作，主动的站在对公司业务帮助最大的角度，站在提升自己能力的角度，把那些最重要的完成了。</p>
<p><strong>罗胖的观点：</strong>面对那些可做可不做的事情，只要有时间就去做。</p>
</blockquote>
<p>愿你在工作之余还能有时间欣赏身边的风景。</p>
<p>以下是文章相关链接：</p>
<ol>
<li><a href="https://www.jianshu.com/p/ba5371bc53b7" target="_blank" rel="external">https://www.jianshu.com/p/ba5371bc53b7</a></li>
<li><a href="https://www.jianshu.com/p/3a33de2675f9" target="_blank" rel="external">https://www.jianshu.com/p/3a33de2675f9</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天听了《吴军硅谷来信-001封信|不做伪工作者》，感触颇多，稍微整理记录一下，分享出来。&lt;/p&gt;
&lt;h2 id=&quot;伪工作者的定义&quot;&gt;&lt;a href=&quot;#伪工作者的定义&quot; class=&quot;headerlink&quot; title=&quot;伪工作者的定义&quot;&gt;&lt;/a&gt;伪工作者的定义&lt;/h2&gt;
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Week1" scheme="http://skyhacks.org/tags/Week1/"/>
    
      <category term="Share" scheme="http://skyhacks.org/tags/Share/"/>
    
  </entry>
  
  <entry>
    <title>Tip_Week1 - Git 换行符（LF和CRLF）问题解决</title>
    <link href="http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Tip_Week1-GitLineEndingCharacter/"/>
    <id>http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Tip_Week1-GitLineEndingCharacter/</id>
    <published>2018-08-19T16:26:35.000Z</published>
    <updated>2018-08-20T15:21:07.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><hr>
<p>在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF）作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。</p>
<h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><hr>
<h3 id="Git设置"><a href="#Git设置" class="headerlink" title="Git设置"></a>Git设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global core.autocrlf false</div><div class="line">git config --global core.safecrlf true</div></pre></td></tr></table></figure>
<h3 id="AutoCRLF"><a href="#AutoCRLF" class="headerlink" title="AutoCRLF"></a>AutoCRLF</h3><p><strong>提交时转换为LF，检出时转换为CRLF</strong><br><code>git config --global core.autocrlf true</code></p>
<p><strong>提交时转换为LF，检出时不转换</strong><br><code>git config --global core.autocrlf input</code></p>
<p><strong>提交检出均不转换</strong><br><code>git config --global core.autocrlf false</code></p>
<h3 id="SafeCRLF"><a href="#SafeCRLF" class="headerlink" title="SafeCRLF"></a>SafeCRLF</h3><p><strong>拒绝提交包含混合换行符的文件</strong><br><code>git config --global core.safecrlf true</code></p>
<p><strong>允许提交包含混合换行符的文件</strong><br><code>git config --global core.safecrlf false</code></p>
<p><strong>提交包含混合换行符的文件时给出警告</strong><br><code>git config --global core.safecrlf warn</code></p>
<h3 id="IDE设置使用UNIX换行符"><a href="#IDE设置使用UNIX换行符" class="headerlink" title="IDE设置使用UNIX换行符"></a>IDE设置使用UNIX换行符</h3><p>IDEA的设置File -&gt; Settings<br>Editor -&gt; Code Style<br>Line separator (for new lines) ，选择：Unix and OS X (\n)</p>
<p>对已使用Windows换行符的文件，可以使用Sublime Text打开，<br>View-&gt;Line Endings，选Unix，保存；</p>
<h2 id="三、后记"><a href="#三、后记" class="headerlink" title="三、后记"></a>三、后记</h2><hr>
<p>以下是自己搭建过程中查找的相关链接和信息，希望对大家有帮助。</p>
<ol>
<li><a href="https://www.cnblogs.com/zjoch/p/5400251.html" target="_blank" rel="external">https://www.cnblogs.com/zjoch/p/5400251.html</a></li>
<li><a href="https://blog.csdn.net/w6248117/article/details/76177103" target="_blank" rel="external">https://blog.csdn.net/w6248117/article/details/76177103</a></li>
<li><a href="https://blog.csdn.net/guodengh/article/details/8630888" target="_blank" rel="external">https://blog.csdn.net/guodengh/article/details/8630888</a></li>
<li><a href="http://kuanghy.github.io/2017/03/19/git-lf-or-crlf" target="_blank" rel="external">http://kuanghy.github.io/2017/03/19/git-lf-or-crlf</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux 使用的是 0x0A（LF），早期的 Mac
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Week1" scheme="http://skyhacks.org/tags/Week1/"/>
    
      <category term="Tip" scheme="http://skyhacks.org/tags/Tip/"/>
    
      <category term="Git" scheme="http://skyhacks.org/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Review_Week1 - What Was Elon Musk Thinking?</title>
    <link href="http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Review_Week1-ElonMuskThinking/"/>
    <id>http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Review_Week1-ElonMuskThinking/</id>
    <published>2018-08-19T16:00:17.000Z</published>
    <updated>2018-08-22T15:44:42.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-Was-Elon-Musk-Thinking"><a href="#What-Was-Elon-Musk-Thinking" class="headerlink" title="What Was Elon Musk Thinking?"></a><a href="https://medium.com/the-new-york-times/what-was-elon-musk-thinking-8166da03f1cc" target="_blank" rel="external">What Was Elon Musk Thinking?</a></h2><p>By James B. Stewart</p>
<p>There’s no question that Elon Musk is one of the great entrepreneurs of this era. He may even be in “a class of one,” as he recently described Tesla, the revolutionary electric car company he founded.<br>毫无疑问，埃隆·马斯克是这个时代最伟大的企业家之一。他甚至也可能是那一类人，他最近提及他创立的革命性的电动汽车公司特斯拉。</p>
<p>But Musk’s tweet last week — expressing his intent to take Tesla private and declaring that he had “funding secured” for the multibillion-dollar transaction — was so impulsive, potentially inaccurate, poorly worded and thought out, and with such potentially dire consequences for himself, Tesla and its shareholders, that the board now must ask a sensitive but vital question: What was Musk’s state of mind when he wrote it?<br>但就在马斯克上周在推特上发文透露他有意将特斯拉私有化，并且声称他有足够的资金担保。推文如此冲动、可能并不准确，措辞不当并且欠缺考虑，对他自己造成了潜在的可怕的后果。特斯拉的股东还有董事此刻一定想问一个敏感但是至关重要的问题：“马斯克在写这些话的时候脑子里到底在想啥？”</p>
<p>“What does this say about the judgment of the person who set all this in motion?” said Charles M. Elson, director of the Weinberg Center for Corporate Governance at the University of Delaware. “That’s what the board has to find out.”<br>“这些所作所为到底说明了什么？”， 特拉华州大学的温伯格公司管理中心的主管Charles M. Elson这么说道，“这也正是董事会想要知道的。”</p>
<p>Musk, in subsequent blog posts, has stressed that he was only trying to be as transparent with the public as he was about to be with a few major investors.<br>马斯克在后续的博客推文中强调他只是想要在和几个主要投资人在一起的时候在公众前变得透明。</p>
<p>That is a laudable goal. But there are plenty of effective, conventional methods for achieving them, which include keeping his board fully informed, consulting lawyers, and following Securities and Exchange Commission procedures before tweeting about what could be a transformative, hugely expensive corporate buyout.<br>这是一个值得赞赏的目标。但在推特上发文要做出一个颠覆性、非常昂贵的公司收购意向前，依然有很多有效并且传统的途径可以达到这些目的，比如在与董事会充分沟通、咨询律师，并且遵循证券交易委员会的程序。</p>
<p>Little if any of this appears to have happened. While Tesla directors have said they discussed with Musk the possibility of taking Tesla private in general terms, they were blindsided by the tweet and have been scrambling ever since to get the situation under control.<br>假如这一切都发生了。特斯拉的主管声称他们已经和马斯克关于将特斯拉私有化的一般条款进行过磋商，他们还是被这条推文弄得措手不及，从那以后就一直在手忙脚乱地控制局面。</p>
<p>The explanation for the tweet may be more psychological than strategic. In a Twitter exchange from last summer, Musk said he experienced “great highs, terrible lows and unrelenting stress.”<br>推特的文字的意义可能心理作用大于战略作用。在去年夏天一次交流中，马斯克曾经表示他体会过巨大的高潮，可怕的低谷和无情的压力。</p>
<p>Asked if he might be bipolar, he replied, “Yeah.” Then he added, “Maybe not medically tho. Dunno. Bad feelings correlate to bad events, so maybe real problem is getting carried away in what I sign up for,” which he later described as a “ticket to hell.”<br>当被问及他是否患有躁郁症时候，马斯克回应，“是的”。然后他补充道：“也许不是医学上认定的那样。坏的情绪总是和坏的事情有关联，所以也许真正的问题是被我所签的东西冲昏了头脑”。他后来描述为“一张通往地狱的车票”。</p>
<p>“Entrepreneurs often have a temperament and a constellation of traits that can create enormous value but are also associated with significant risks,” said Michael A. Freeman, a clinical professor of psychiatry at the University of California, San Francisco, whose research and practice focuses on entrepreneurs.<br>“企业家总是有一些喜怒无常和一个星座的特质，这些东西可以创造巨大的价值，但是也伴随着巨大的危险”。旧金山加州大学的精神病学临床教授Michael A. Freeman如此说道。他的研究的对象是一些企业家。</p>
<p>While Freeman said he couldn’t comment on Musk, whom he’s never treated, he said that his research and experience with clients show that entrepreneurs generally “have mental health profiles that are associated with higher levels of creativity, higher levels of energy, higher levels of risk tolerance and higher levels of impulsivity. Another way to look at impulsivity is a need for speed, a sense of urgency, higher motivation, and greater restlessness.”<br>但是Freeman说他不能对马斯克做出任何评价，因为他从未诊治过他。他研究经历显示通常患有精神病症的企业家都拥有更高水平的创造力、精力、风险承受能力和、冲动。另一种看待冲动的方式是对速度的需要，一种紧迫感，更高的动力，和更大的不安。</p>
<p>All of that would seem consistent with Musk’s Twitter habits.<br>所有这些似乎都与马斯克的Twitter习惯相一致。</p>
<p>Scott Shane, a professor of entrepreneurial studies at Case Western Reserve University, put it more simply: “These people are just wired differently,” he said. “They’re quicker to spot and act on opportunities, but that same tendency can get them into trouble in other situations.”<br>凯斯西储大学的创业研究教授Scott Shane说的更简单：“这些人只是精力不一样，他们会更快地发现并采取行动，但同样的趋势会让他们在其他情况下陷入麻烦。”</p>
<p>These qualities may also be exacerbated by lack of sleep. Musk has said he’s been sleeping on the factory floor, skipping showers, and working extremely long hours while Tesla ramps up production of its Model 3.<br>这些品质可能因为缺乏睡眠而加重。马斯卡曾提及在特斯拉增加Model 3的产量期间，他睡在工厂的地板上，没时间洗澡，长时间的工作。</p>
<p>“There are a number of behavioral destabilizers in the world of entrepreneurship,” Freeman said, “and sleep deficiency is high on the list. The consequences can be impaired functioning, higher irritability, and judgment can be adversely affected.”<br>“在创业的世界里有很多行为不稳定的人”, Freeman 说道，“睡眠不足很常见。直接导致的后果是身体功能受损、易怒、判断可能受到不利影响。”</p>
<p>During Tesla’s most recent earnings conference call, Musk apologized to Wall Street analysts he had insulted during a previous call for asking “boring, bonehead questions.”<br>在特斯拉最近的财报会议上，马斯克为自己在上一次财报会上的无礼向华尔街分析家道歉，他当时侮辱了“无聊的、愚蠢的问题”。</p>
<p>“There are reasons for it. I’ve gotten no sleep and been working sort of 110-hour, 120-hour weeks,” he said.<br>“对此我有足够的理由。我没时间睡觉，并且一周连续工作110-120小时”，他解释道。</p>
<p>It’s also a common trait of entrepreneurs that they feel rules don’t apply to them. From their perspective, many rules “get in the way of getting things done,” Freeman said.<br>创业者普遍有一个特质，他们认为规则并不适用。“从他们的角度来说，一些规则总是阻碍把事情搞定。” Freeman说道。</p>
<p>Whatever the exact circumstances of his tweet, Musk would benefit from what Freeman calls “personal boards of directors,” something he often recommends for his entrepreneurial clients. “There are some simple strategies for dealing with impulsivity, like sleep on something overnight and get a second opinion,” he said. “If you’re hard-wired to go full speed ahead at all times, you need to create a filter for yourself to decrease those risk factors.”<br>不管他的推文的具体情况如何，马斯克将会从Freeman所说的“个人董事会”中受益。有些东西他总是推荐给他的企业客户，“有一些简单的方法用于处理冲动，比如睡一觉之后得到第二种想法”，马斯克说道，“如果你在任何时候都要全速前进，你需要为自己创建一个过滤器来减少这些风险因素”。</p>
<p>Tesla’s board should play an important role. “Balancing corporate responsibilities, and the constraints they can impose, against the creativity that made the corporation great in the first place is much more of an art than a science,” said Charles Whitehead, who leads the law, technology and entrepreneurship program at Cornell Law School. “Directors and lawyers need to credibly manage that balance, but as importantly, founders need to be willing to consult with them, recognizing that the advice — even if it slows things down — may simply reflect the realities of the day.”<br>特斯拉的董事会需要扮演一个重要的角色，“相对创造力使得企业领先来说，平衡企业责任，以及他们可以施加的约束更像是一门艺术而非科学”，在康奈尔法学院领导法律、技术和创业项目的Charles Whitehead说道。“董事和律师需要可靠地管理这种平衡， 但更重要的是，创始人意向去和他们咨询、认可简单地反映当今的现实的建议， 尽管它们可能会减缓事情发展的速度”。</p>
<p>Freeman agreed. The Tesla board and others close to Musk “need to find ways to make all the positive aspects of those strengths work for him and for us while minimizing the downside.”<br>Freeman提出，“特斯拉的董事会和其他与马斯克关系密切的人应当找到合适的方法让所有这些优势的工作成为积极方面的同时尽量减少不利方面。”</p>
<p>And Musk may want to curb his use of Twitter. “One good rule of thumb: never make important, and in Tesla’s case, complex announcements through Twitter,” Whitehead said.<br>“马斯克可能想要限制他对Twitter的使用的一个好的原则就是：绝不通过twitter上做出想特斯拉案例中的重要和复杂的通告”，Whitehead说道。</p>
<p>That may be easier said than done. Tesla’s board members have been urging Musk to stop tweeting, so far without success.<br>这可能是说比做容易。特斯拉的董事会成员一直在敦促马斯克停止推特，到目前为止还没有成功。</p>
<p>“It’s not easy for anyone to control the behavior of a grand visionary,” Shane said. “These people don’t like to be controlled.”<br>Shane说道：“要控制一个伟大的梦想家的行为并非易事。这些人从来不喜欢被控制”。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-Was-Elon-Musk-Thinking&quot;&gt;&lt;a href=&quot;#What-Was-Elon-Musk-Thinking&quot; class=&quot;headerlink&quot; title=&quot;What Was Elon Musk Thinking?&quot;&gt;&lt;/a&gt;&lt;a h
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Review" scheme="http://skyhacks.org/tags/Review/"/>
    
      <category term="Week1" scheme="http://skyhacks.org/tags/Week1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 832. Flipping an Image</title>
    <link href="http://skyhacks.org/2018/08/19/LeetCode/LeetCode-FlippingAnImage/"/>
    <id>http://skyhacks.org/2018/08/19/LeetCode/LeetCode-FlippingAnImage/</id>
    <published>2018-08-19T01:29:04.000Z</published>
    <updated>2018-08-22T15:53:05.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/flipping-an-image" target="_blank" rel="external">题目描述</a>：</h2><p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.<br>To flip an image horizontally means that each row of the image is reversed.  For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].<br>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0].</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [[1,1,0],[1,0,1],[0,0,0]]</div><div class="line">Output: [[1,0,0],[0,1,0],[1,1,1]]</div><div class="line">Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].</div><div class="line">Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]</div></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</div><div class="line">Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</div><div class="line">Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].</div><div class="line">Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> &lt;= A.length = A[<span class="number">0</span>].length &lt;= <span class="number">20</span></div><div class="line"><span class="number">0</span> &lt;= A[i][j] &lt;= <span class="number">1</span></div></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>根据给出的例子可以发现规则：<br>翻转图像矩阵的每一行，并且对每一个元素取反</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><hr>
<p>这道题总共要做2件事：</p>
<pre><code>1. 数组中的每个单元逆序
2. 数组中的每个单元内的元素求反
</code></pre><p>参考LeetCode Discuss：<br><a href="https://leetcode.com/problems/flipping-an-image/discuss/130590/C++JavaPython-Reverse-and-Toggle" target="_blank" rel="external">https://leetcode.com/problems/flipping-an-image/discuss/130590/C++JavaPython-Reverse-and-Toggle</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; flipAndInvertImage(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vRes = A;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == vRes.size()) <span class="keyword">return</span> vRes;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; vRes.size(); idx++) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v = vRes[idx];</div><div class="line">            reverse(v.begin(), v.end());</div><div class="line"></div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin();</div><div class="line">            <span class="keyword">for</span> (; it != v.end(); it++) &#123;</div><div class="line">                *it = *it ^ <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> vRes;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br>此题元素求反可以考虑（数组内的元素非0即1）：</p>
<pre><code>1. 元素本身异或
2. 元素本身求反
3. 代码本身判断
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/flipping-an-image&quot; target=&quot;_blan
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>ARTS - 左耳听风群的每周必做</title>
    <link href="http://skyhacks.org/2018/08/14/Arts/MyArtsPlan/"/>
    <id>http://skyhacks.org/2018/08/14/Arts/MyArtsPlan/</id>
    <published>2018-08-14T15:14:41.000Z</published>
    <updated>2018-09-13T15:34:16.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>每周至少做一个leetcode算法题</p>
<ul>
<li>week1: <a href="http://skyhacks.org/2018/08/21/Arts/Week1/Arts-Share-Week1-HowToWork/">832.Flipping an Image</a></li>
<li>week2: <a href="http://skyhacks.org/2018/08/30/LeetCode/LeetCode-TransposeMatrix/">867. Transpose Matrix</a></li>
<li>week3: <a href="http://skyhacks.org/2018/09/05/LeetCode/LeetCode-ToeplitzMatrix/">766. Toeplitz Matrix</a></li>
</ul>
<hr>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>每周阅读至少一篇英文技术文章</p>
<ul>
<li>week1: <a href="http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Review_Week1-ElonMuskThinking/">马斯克在想什么？</a></li>
<li>week2: <a href="http://skyhacks.org/2018/08/25/Arts/Week2/Arts-Review_Week2-MyArtsPlan/">在Facebook服务器上执行远程代码执行</a></li>
<li>week3: <a href="http://skyhacks.org/2018/09/07/Arts/Week3/Arts-Review_Week3-HowToThinkLikeProgrammer/">如何像程序员一样思考</a></li>
</ul>
<hr>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>每周学习至少一个技术技巧, 最好是实际工作学到的</p>
<ul>
<li>week1: <a href="http://skyhacks.org/2018/08/20/Arts/Week1/Arts-Tip_Week1-GitLineEndingCharacter/">Git换行符LF与CRLF转换问题</a></li>
<li>week2: <a href="http://skyhacks.org/2018/08/29/Arts/Week2/Arts-Tip-Week2-HexoDeployGithub/">使用Hexo和GitHub搭建博客，出现hexo -d报错解决方案</a></li>
<li>week3: <a href="http://skyhacks.org/2018/09/09/Arts/Week3/Arts-Tip-Week3-CodeDiffTool/">Code Diff工具分享</a></li>
</ul>
<hr>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>每周分享一篇有观点和思考的技术文章</p>
<ul>
<li>week1: <a href="http://skyhacks.org/2018/08/21/Arts/Week1/Arts-Share-Week1-HowToWork/">不做伪工作者</a></li>
<li>week2: <a href="http://skyhacks.org/2018/08/30/Arts/Week2/Arts-Share-Week2-HowToAskQuestions/">如何正确高效地问对问题</a></li>
<li>week3: <a href="http://skyhacks.org/2018/09/06/Arts/Week3/Arts-Share-Week3-HowToStudy/">如何高效的学习</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;每周至少做一个leetcode算法题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;week1: &lt;a 
    
    </summary>
    
      <category term="Arts" scheme="http://skyhacks.org/categories/Arts/"/>
    
    
      <category term="Arts" scheme="http://skyhacks.org/tags/Arts/"/>
    
      <category term="Blog" scheme="http://skyhacks.org/tags/Blog/"/>
    
      <category term="GitHub" scheme="http://skyhacks.org/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 717. 1-bit and 2-bit Characters</title>
    <link href="http://skyhacks.org/2017/12/01/LeetCode/LeetCode-1-bitand2-bitCharacters/"/>
    <id>http://skyhacks.org/2017/12/01/LeetCode/LeetCode-1-bitand2-bitCharacters/</id>
    <published>2017-12-01T09:22:49.000Z</published>
    <updated>2018-08-19T01:41:47.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/1-bit-and-2-bit-characters" target="_blank" rel="external">题目描述</a>：</h2><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).<br>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">bits = [1, 0, 0]</div><div class="line">Output: True</div><div class="line">Explanation:</div><div class="line">The only way to decode it is two-bit character and one-bit character. So the last character</div><div class="line">is one-bit character.</div></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">bits = [1, 1, 1, 0]</div><div class="line">Output: False</div><div class="line">Explanation:</div><div class="line">The only way to decode it is two-bit character and two-bit character. So the last character</div><div class="line">is NOT one-bit character.</div></pre></td></tr></table></figure></p>
<p><strong>Note:</strong><br>    <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span> &lt;= len(bits) &lt;= <span class="number">1000.</span></div><div class="line">bits[i] is always <span class="number">0</span> <span class="keyword">or</span> <span class="number">1.</span></div></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>01序列由三种成分构成：10, 11, 0<br>求序列经过解析后，最后一个成分是否为0</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><hr>
<p>这道题就是已知一个字符串（最后一个字符0）和三种构成成分，判定该字符串是否合法。<br>观察三种字符串可以发现，两bits的只有10和11两种（第一个bit都是1，第二bit随意），一个bit的只有0满足。<br>转变思路后就是检查一个最后一个bit是0的字符串中是否存在单个bit是1的情况（00可以解析为2个bit的0组成）。</p>
<p>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/108743/java-solution-1-or-2/4" target="_blank" rel="external">https://discuss.leetcode.com/topic/108743/java-solution-1-or-2/4</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bits)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = bits.size(), i = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (i &lt; n<span class="number">-1</span>) i += bits[i]+<span class="number">1</span>; </div><div class="line">        <span class="keyword">return</span> i == n<span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br>此题没有运用一个通用的算法，而是根据题目的特性做出解答，具体步骤就是</p>
<pre><code>1. 放置一个指针在字符串首位用于遍历
2. 每次看见0的时候，往前走1步
3. 每次看见1的时候（可以认为是发现11或者10），往前走2步
4. 假如出现单个1的时候，指针往前走2步就可能超过字符串的本身长度，这种情况就是不符合题意的case。
正常遍历是可以最终到达n-1的位置（n为字符串长度）
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/1-bit-and-2-bit-characters&quot; targ
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 169. Majority Element II</title>
    <link href="http://skyhacks.org/2017/11/28/LeetCode/LeetCode-MajorityElementII/"/>
    <id>http://skyhacks.org/2017/11/28/LeetCode/LeetCode-MajorityElementII/</id>
    <published>2017-11-28T03:42:33.000Z</published>
    <updated>2018-08-14T15:31:31.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/majority-element-ii" target="_blank" rel="external">题目描述</a>：</h2><p>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. The algorithm should run in linear time and in O(1) space.<br>Hint:<br>How many majority elements could it possibly have?</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个大小为n的整数数组，从中找出所有出现次数超过 ⌊ n/3 ⌋ 的元素。算法应该满足线性时间复杂度和O(1)空间复杂度。<br>提示：<br>一共可能有多少个“众数”？</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><hr>
<p>可以从<a href="http://blog.csdn.net/chfe007/article/details/42919017" target="_blank" rel="external">Moore’s voting algorithm</a>中得到一些启发</p>
<p>参考LeetCode Discuss：<br><a href="https://leetcode.com/discuss/43248/boyer-moore-majority-vote-algorithm-and-my-elaboration" target="_blank" rel="external">https://leetcode.com/discuss/43248/boyer-moore-majority-vote-algorithm-and-my-elaboration</a></p>
<p>观察可知，数组中至多可能会有2个出现次数超过 ⌊ n/3 ⌋ 的众数<br>记变量n1, n2为候选众数； c1, c2为它们对应的出现次数<br>遍历数组，记当前数字为num<br>若num与n1或n2相同，则将其对应的出现次数加1<br>否则，若c1或c2为0，则将其置为1，对应的候选众数置为num<br>否则，将c1与c2分别减1<br>最后，再统计一次候选众数在数组中出现的次数，若满足要求，则返回之。</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorityElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; majorList;</div><div class="line">        <span class="comment">// first round to find the candidates</span></div><div class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> candidate1 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> count2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> candidate2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</div><div class="line">             <span class="comment">// every iteration deal with one possibility</span></div><div class="line">            <span class="keyword">if</span> (candidate1 == nums[i]) count1++;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (candidate2 == nums[i]) count2++;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == count1) &#123;</div><div class="line">                count1 = <span class="number">1</span>;</div><div class="line">                candidate1 = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == count2) &#123;</div><div class="line">                count2 = <span class="number">1</span>;</div><div class="line">                candidate2 = nums[i];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                count1--;</div><div class="line">                count2--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// second round to check</span></div><div class="line">        <span class="comment">// notice that num1 and num2 can be the same, but in the following we only count once!</span></div><div class="line">        count1 = count2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[i] == candidate1) count1++;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == candidate2) count2++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (nums.size()/<span class="number">3</span> &lt; count1)</div><div class="line">            majorList.push_back(candidate1);</div><div class="line">        <span class="keyword">if</span> (nums.size()/<span class="number">3</span> &lt; count2)</div><div class="line">            majorList.push_back(candidate2);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> majorList;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br>此题是<a href="http://skyhacks.org/2017/11/24/LeetCode-MajorityElement">LeetCode 169. Majority Element</a>的加强版，同时要找出大于n/3的众数，难点在于</p>
<pre><code>1. 时间复杂度O(n)，空间复杂度O(1) -- 注定只能遍历元素，并且用单个变量来完成计数
2. 众数的条件是n/3
</code></pre><p>针对此题的n/3的进行深入分析，可以发现有三种情况：</p>
<pre><code>1. 不存在大于n/3的众数，第一轮结束后，第二轮check时候就会把非众数都过滤掉。
2. 只存在1个大于n/3的众数, 其余元素个数总数小于2n/3。递减(pair out)时候可以保证众数的count不为0, 第二轮check时候
就会把非众数都过滤掉。
3. 存在2个大于n/3的众数，其余元素都小于n/3。递减(pair out)时候可以保证2个众数的count不为0, 第二轮check时候
就会把非众数都过滤掉。
</code></pre><p><strong>Boyer-Moore Majority Vote algorithm</strong>的拓展：</p>
<ol>
<li><a href="https://discuss.leetcode.com/topic/65042/my-understanding-of-boyer-moore-majority-vote" target="_blank" rel="external">https://discuss.leetcode.com/topic/65042/my-understanding-of-boyer-moore-majority-vote</a></li>
<li><a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html" target="_blank" rel="external">https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/majority-element-ii&quot; target=&quot;_bl
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="Majority Element" scheme="http://skyhacks.org/tags/Majority-Element/"/>
    
      <category term="Moore’s voting algorithm" scheme="http://skyhacks.org/tags/Moore%E2%80%99s-voting-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 169. Majority Element</title>
    <link href="http://skyhacks.org/2017/11/24/LeetCode/LeetCode-MajorityElement/"/>
    <id>http://skyhacks.org/2017/11/24/LeetCode/LeetCode-MajorityElement/</id>
    <published>2017-11-24T09:27:42.000Z</published>
    <updated>2018-08-14T15:31:31.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="external">题目描述</a>：</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.<br>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为n的数组，寻找其中的“众数”。众数是指出现次数大于 ⌊ n/2 ⌋ 的元素。<br>你可以假设数组是非空的并且数组中的众数永远存在。</p>
<h2 id="参考LeetCode-Discuss："><a href="#参考LeetCode-Discuss：" class="headerlink" title="参考LeetCode Discuss："></a>参考LeetCode Discuss：</h2><p><a href="https://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution/20" target="_blank" rel="external">https://discuss.leetcode.com/topic/8692/o-n-time-o-1-space-fastest-solution/20</a><br><a href="https://discuss.leetcode.com/topic/17446/6-suggested-solutions-in-c-with-explanations" target="_blank" rel="external">https://discuss.leetcode.com/topic/17446/6-suggested-solutions-in-c-with-explanations</a></p>
<h3 id="解题思路1："><a href="#解题思路1：" class="headerlink" title="解题思路1："></a>解题思路1：</h3><hr>
<p>HashTable：使用HashTasble给每个出现的元素计数，遍历数组，发现超过半数的众数就返回。</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</div><div class="line">            ++mapNums[nums[i]];</div><div class="line">            <span class="keyword">if</span> (mapNums[nums[i]] &gt; nums.size() / <span class="number">2</span>) <span class="keyword">return</span> nums[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br>时间复杂度满足O(n)，但是由于HashTable（unordered_map）的存在，空间复杂度就不能满足O(1)。</p>
<h3 id="解题思路2："><a href="#解题思路2：" class="headerlink" title="解题思路2："></a>解题思路2：</h3><hr>
<p>排序：排序的结果就是众数如果存在，中间的元素一定是众数（过半）</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">return</span> (nums.size() / <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<ol>
<li>时间复杂度主要在排序上， N*log2(N)</li>
<li>如果数组为空或者不存在众数，上述代码需要考虑更全面些 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        sort(nums.begin(), nums.end());</div><div class="line">        <span class="keyword">int</span> pivot = nums.size() / <span class="number">2</span>;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pivot; i &lt; nums.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[pivot] != nums[i]) <span class="keyword">break</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pivot - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span> (nums[pivot] != nums[i]) <span class="keyword">break</span>;</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (count &gt; pivot) <span class="keyword">return</span> nums[pivot];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="解题思路3："><a href="#解题思路3：" class="headerlink" title="解题思路3："></a>解题思路3：</h3><hr>
<p>投票算法：遍历元素，利用candidate 和 count两个变量找到众数。（前提：众数一定存在）</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> major = nums, counts = <span class="number">0</span>, n = nums.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (!counts) &#123;</div><div class="line">                major = nums[i];</div><div class="line">                counts = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> counts += (nums[i] == major) ? <span class="number">1</span> : <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> major;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br><a href="http://blog.csdn.net/chfe007/article/details/42919017" target="_blank" rel="external">Moore’s voting algorithm</a>是比较有意思的一个算法，在dicuss上看到的。这个算法是解决这样一个问题：从一个数组中找出出现半数以上的元素。大意是这样：</p>
<blockquote>
<p>We will sweep down the sequence starting at the pointer position shown above. As we sweep we maintain a pair consisting of a current candidate and a counter. Initially, the current candidate is unknown and the counter is 0.<br>When we move the pointer forward over an element e:</p>
<ul>
<li>If the counter is 0, we set the current candidate to e and we set the counter to 1.</li>
<li>If the counter is not 0, we increment or decrement the counter according to whether e is the current candidate.<br>When we are done, the current candidate is the majority element, if there is a majority.</li>
</ul>
</blockquote>
<p><strong>“投票算法”</strong><br>设定两个变量candidate和count。candidate保存当前可能的候选众数，count保存该候选众数的出现次数。<br>遍历数组num。<br>如果当前的数字e与候选众数candidate相同，则将计数count + 1<br>否则，如果当前的候选众数candidate为空，或者count为0，则将候选众数candidate的值置为e，并将计数count置为1。<br>否则，将计数count - 1<br>最终留下的候选众数candidate即为最终答案。<br>以上算法时间复杂度为O(n)，空间复杂度为O(1)</p>
<h2 id="官方解析："><a href="#官方解析：" class="headerlink" title="官方解析："></a>官方解析：</h2><p>时间复杂度: O(n2) — 蛮力法: 依次检查每一个元素是否为众数<br>时间复杂度: O(n), 空间复杂度: O(n) — 哈希表: 维护一个每一个元素出现次数的哈希表, 然后找到出现次数最多的元素<br>时间复杂度: O(n log n) — 排序: 在排序后找出连续重复出现次数最多的元素<br>平均时间复杂度: O(n), 最坏复杂度: 无穷大 — 随机算法: 随机选取一个元素计算其是否为众数. 如果不是, 就重复上一步骤直到找到为止。 由于选出众数的概率 &gt; 1 / 2, 因此期望的尝试次数 &lt; 2<br>时间复杂度: O(n log n) — 分治法: 将数组拆成2半, 然后找出前一半的众数A和后一半的众数B。则全局众数要么是A要么是B。 如果 A == B, 则它自然而然就是全局众数。 如果不是, 则A和B都是候选众数, 则至多只需要检查这两个元素的出现次数即可。 时间复杂度, T(n) = T(n/2) + 2n = O(n log n).<br>时间复杂度: O(n) — Moore投票算法: 我们维护一个当前的候选众数和一个初始为0的计数器。遍历数组时，我们看当前的元素x:</p>
<pre><code>* 如果计数器是0, 我们将候选众数置为 x 并将计数器置为 1
* 如果计数器非0, 我们根据x与当前的候选众数是否相等对计数器+1或者-1
* 一趟之后, 当前的候选众数就是所求众数. 时间复杂度 = O(n).
</code></pre><p>时间复杂度: O(n) — 位操作法: 我们需要32次迭代, 每一次计算所有n个数的第i位的1的个数。由于众数一定存在，那么或者1的个数&gt;0的个数 或者反过来(但绝不会相同)。 众数的第i位一定是计数较多数字。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/majority-element/description/&quot; t
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="Sort" scheme="http://skyhacks.org/tags/Sort/"/>
    
      <category term="HashTable" scheme="http://skyhacks.org/tags/HashTable/"/>
    
      <category term="Majority Element" scheme="http://skyhacks.org/tags/Majority-Element/"/>
    
      <category term="Moore’s voting algorithm" scheme="http://skyhacks.org/tags/Moore%E2%80%99s-voting-algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 121. Best Time to Buy and Sell Stock</title>
    <link href="http://skyhacks.org/2017/11/23/LeetCode/LeetCode-BestTimetoBuyandSellStock/"/>
    <id>http://skyhacks.org/2017/11/23/LeetCode/LeetCode-BestTimetoBuyandSellStock/</id>
    <published>2017-11-23T04:11:53.000Z</published>
    <updated>2018-08-14T15:31:31.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="external">题目描述</a>：</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 1, 5, 3, 6, 4]</div><div class="line">Output: 5</div><div class="line"></div><div class="line">max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</div></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Input: [7, 6, 4, 3, 1]</div><div class="line">Output: 0</div><div class="line"></div><div class="line">In this case, no transaction is done, i.e. max profit = 0.</div></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给一个数组prices[]，prices[i]代表股票在第i天的售价，求出只做一次交易(一次买入和卖出)能得到的最大收益。 </p>
<h3 id="解题思路1："><a href="#解题思路1：" class="headerlink" title="解题思路1："></a>解题思路1：</h3><hr>
<p>Brute &amp; Force（直观做法）: 两个循环，逐一找到每两个元素的差值，取最大的即为为maxProfit，时间复杂度O(n^2)</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; prices.size(); j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span> &lt; prices[j] - prices[i])</div><div class="line">                    maxProfit = max(prices[j] - prices[i], maxProfit);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 遍历数组，找到MaxProfit（效率较低）
2. 保证每一次比较的差值都是正值即可
</code></pre><h3 id="解题思路2："><a href="#解题思路2：" class="headerlink" title="解题思路2："></a>解题思路2：</h3><hr>
<p>根据题目意思，只需要找出一次交易的最大的差值。对于此题就是要找到最小值（下限）和最大值（上限）。<br>只要能固定住其中之一，就可以通过一次遍历，时间复杂度O(n)，找到maxProfit.<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/2" target="_blank" rel="external">https://discuss.leetcode.com/topic/5863/sharing-my-simple-and-clear-c-solution/2</a><br><a href="https://discuss.leetcode.com/topic/2763/a-o-1-n-solution" target="_blank" rel="external">https://discuss.leetcode.com/topic/2763/a-o-1-n-solution</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minPrice = INT_MAX;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</div><div class="line">            minPrice = min(minPrice, prices[i]);</div><div class="line">            maxProfit = max(maxProfit, prices[i] - minPrice);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 将如何获得maxProfit的问题转化为：取出maxProfit和prices[i] - minPrice之间的最大差值
2. 通过观察发现并不是每一次迭代都需要去计算minPrice，可以优化为以下代码
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> minPrice = INT_MAX;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</div><div class="line">            <span class="keyword">if</span> (prices[i] &lt; minPrice)</div><div class="line">                minPrice = min(minPrice , prices[i]);</div><div class="line">            maxProfit = max(maxProfit, prices[i] - minPrice);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxProfit;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p><strong>拓展:</strong><br>    <a href="https://discuss.leetcode.com/topic/19853/kadane-s-algorithm-since-no-one-has-mentioned-about-this-so-far-in-case-if-interviewer-twists-the-input/5" target="_blank" rel="external">Kadane’s Algorithm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="Kadane&#39;s Algorithm" scheme="http://skyhacks.org/tags/Kadane-s-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 122. Best Time to Buy and Sell Stock II</title>
    <link href="http://skyhacks.org/2017/11/21/LeetCode/LeetCode-BestTimetoBuyandSellStockII/"/>
    <id>http://skyhacks.org/2017/11/21/LeetCode/LeetCode-BestTimetoBuyandSellStockII/</id>
    <published>2017-11-21T02:30:50.000Z</published>
    <updated>2018-08-14T15:31:31.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/" target="_blank" rel="external">题目描述</a>：</h2><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。<br>给出一个数组样例[2,1,2,0,1], 返回 2</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><hr>
<p>这个是一道DP(动态规划)的题。总的来说就是如何N天的总利润如何最大呢？就是一旦有获利空间就去赚钱，所以就是把每两天的价格增长量加起来就是总利润了，如果存在两天的价格增长量为负，那么就不进行交易。同一天买卖，收益为0，所以需要隔天买卖，保证利润增值。<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/17081/three-lines-in-c-with-explanation" target="_blank" rel="external">https://discuss.leetcode.com/topic/17081/three-lines-in-c-with-explanation</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> p = <span class="number">1</span>; p &lt; prices.size(); ++p)</div><div class="line">          <span class="comment">// Only consider positive value to make sure get max profit</span></div><div class="line">          ret += max(prices[p] - prices[p - <span class="number">1</span>], <span class="number">0</span>); </div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 题意为给定一个数组，数组中第i个元素的值对应着第i天的股票，你可以完成多次交易，但是每次交易只能买入一次并卖出,求进行
多次交易所能得到的最大利润。该题为Best Time to Buy and Sell Stock的加强版。
2. 与Best Time to Buy and Sell Stock类似，该题同样考查的是最大差值。只不过该题考查数组中所有相邻且递增元素
的数值之差的总和。只要第i+1天的值大于第i天的值，则可买入，求得利润（差值），遍历整个数组，得到所用差值之和即为总的利润。
负值则跳过。充分体现了DP的精髓，局部最优就是整体最优解。
3. 假设有四个数字，&quot;a &lt;= b &lt;= c &lt;= d&quot;, the profit is &quot;d - a = (b - a) + (c - b) + (d - c)&quot;。
例如[5,8,9,10],maxProfit=(8-5)+(9-8)+(10-9)=10-5=5; // 这是理想情况
假如其中有负值，则跳过这几个元素，直到获取正值，保证利润都是递增。
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="DP" scheme="http://skyhacks.org/tags/DP/"/>
    
      <category term="Dynamic Programming" scheme="http://skyhacks.org/tags/Dynamic-Programming/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 463. Island Perimeter</title>
    <link href="http://skyhacks.org/2017/11/17/LeetCode/LeetCode-IslandPerimeter/"/>
    <id>http://skyhacks.org/2017/11/17/LeetCode/LeetCode-IslandPerimeter/</id>
    <published>2017-11-17T08:09:05.000Z</published>
    <updated>2017-11-20T13:16:51.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/island-perimeter/description/" target="_blank" rel="external">题目描述</a>：</h2><p>You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes” (water inside that isn’t connected to the water around the island). One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island.<br><strong>Example:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[0,1,0,0],</div><div class="line">[1,1,1,0],</div><div class="line">[0,1,0,0],</div><div class="line">[1,1,0,0]]</div><div class="line"></div><div class="line">Answer: 16</div></pre></td></tr></table></figure></p>
<p>Explanation: The perimeter is the 16 yellow stripes in the image below:<br><img src="http://otqlqfy9h.bkt.clouddn.com/images/2017-11-17/2017_11_17_1.png"></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个二维地图，1表示陆地，0表示水域。单元格水平或者竖直相连（不含对角线）。地图完全被水域环绕，只包含一个岛屿（也就是说，一个或者多个相连的陆地单元格）。岛屿没有湖泊（岛屿内部环绕的水域）。单元格是边长为1的正方形。地图是矩形，长宽不超过100。计算岛屿的周长。</p>
<h3 id="解题思路1："><a href="#解题思路1：" class="headerlink" title="解题思路1："></a>解题思路1：</h3><hr>
<p>DFS：深度优先遍历（递归实现）, 虑每个元素的四个方向，如果是边界或者0，则perimeter+1。<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/106301/java-c-straightforward-dfs-solution" target="_blank" rel="external">https://discuss.leetcode.com/topic/106301/java-c-straightforward-dfs-solution</a><br><a href="https://discuss.leetcode.com/topic/106261/java-c-clean-code" target="_blank" rel="external">https://discuss.leetcode.com/topic/106261/java-c-clean-code</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> m = grid.size();</div><div class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="number">1</span> == grid[i][j])</div><div class="line">                    nums += bfs(grid, i, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.size() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].size()</div><div class="line">            || <span class="number">0</span> == grid[i][j])</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// stripes</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-1</span> == grid[i][j])</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            grid[i][j] = <span class="number">-1</span>; <span class="comment">// mark visited</span></div><div class="line">            <span class="keyword">return</span> dfs(grid, i - <span class="number">1</span>, j) + dfs(grid, i + <span class="number">1</span>, j)</div><div class="line">            + dfs(grid, i, j - <span class="number">1</span>) + dfs(grid, i, j + <span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素
2. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)]
3. 如果是边界点或者grid[i][j]为0的情况，则perimeter + 1
4. 访问过的元素置为-1，与原数组元素值区分。
5. 二维数组的vector表示
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; grid(<span class="number">4</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</div><div class="line">    grid[i].resize(<span class="number">4</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">        grid[i][j] = arr[i][j];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解题思路2："><a href="#解题思路2：" class="headerlink" title="解题思路2："></a>解题思路2：</h3><hr>
<p>BFS：广度优先遍历（借助队列迭代实现）<br>参考LeetCode Discuss：</p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> m = grid.size();</div><div class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="number">1</span> == grid[i][j])</div><div class="line">                    nums += bfs(grid, i, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</div><div class="line">        grid[i][j] = <span class="number">-1</span>; <span class="comment">// visited</span></div><div class="line"></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir(&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;); <span class="comment">// c++11/14</span></div><div class="line">        <span class="comment">// int nums[] = &#123;-1, 0, 1, 0, -1&#125;;</span></div><div class="line">        <span class="comment">// vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int));</span></div><div class="line">        q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, j));</div><div class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; q.size()) &#123;</div><div class="line">            <span class="keyword">int</span> m = q.front().first; <span class="comment">// row index</span></div><div class="line">            <span class="keyword">int</span> n = q.front().second; <span class="comment">// col index</span></div><div class="line">            q.pop(); <span class="comment">// remove from queue</span></div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; dir.size() - <span class="number">1</span>; idx++) &#123;</div><div class="line">                <span class="keyword">int</span> rowIdx = m + dir[idx]; <span class="comment">// row index</span></div><div class="line">                <span class="keyword">int</span> colIdx = n + dir[idx + <span class="number">1</span>]; <span class="comment">// col index</span></div><div class="line">                <span class="keyword">if</span> (rowIdx &lt; <span class="number">0</span> || rowIdx &gt;= grid.size() || colIdx &lt; <span class="number">0</span> || colIdx &gt;= grid[<span class="number">0</span>].size()</div><div class="line">                    || <span class="number">0</span> == grid[rowIdx][colIdx])</div><div class="line">                    nums++; <span class="comment">//  accumulate stripes</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">-1</span> == grid[rowIdx][colIdx])</div><div class="line">                    <span class="keyword">continue</span>; <span class="comment">// skip visted item</span></div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(rowIdx, colIdx));</div><div class="line">                    grid[rowIdx][colIdx] = <span class="number">-1</span>; <span class="comment">// mark visited</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素
2. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)]
3. 如果是边界点或者grid[i][j]为0的情况，则perimeter + 1
4. 访问过的元素置为-1，与原数组元素值区分。
5. 二维数组的vector表示
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> arr[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; grid(<span class="number">4</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++)</div><div class="line">    grid[i].resize(<span class="number">4</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">        grid[i][j] = arr[i][j];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解题思路3："><a href="#解题思路3：" class="headerlink" title="解题思路3："></a>解题思路3：</h3><hr>
<p>代码简洁的全遍历，复杂度O(n)。<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/111260/c-short-and-fast-beats-93" target="_blank" rel="external">https://discuss.leetcode.com/topic/111260/c-short-and-fast-beats-93</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i)</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j)</div><div class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</div><div class="line">                    p += (i == <span class="number">0</span> || grid[i - <span class="number">1</span>][j] == <span class="number">0</span>) + (i == grid.size() - <span class="number">1</span> || grid[i + <span class="number">1</span>][j] == <span class="number">0</span>) +</div><div class="line">                         (j == <span class="number">0</span> || grid[i][j - <span class="number">1</span>] == <span class="number">0</span>) + (j == grid[i].size() - <span class="number">1</span> || grid[i][j + <span class="number">1</span>] == <span class="number">0</span>);</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 代的方式进行全遍历，代码比较简洁。不过就是循环内嵌套过多的逻辑判断，效率比较低。
2. 关注点在确定当前grid[i][j]为1后，观察四个方向的元素是否为0，如果是则+1.如果是i = 0或者j=0的边界则直接+1；
</code></pre><h3 id="解题思路4："><a href="#解题思路4：" class="headerlink" title="解题思路4："></a>解题思路4：</h3><hr>
<pre><code>1. 确定“1”的个数，如果没有相邻包围的元素的话，perimeter为“1”的个数×4
2. 确定相邻的元素边界墙的个数，需要减去从上述结果中减去2×边界墙个数
</code></pre><p>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/68845/c-solution-with-explanation" target="_blank" rel="external">https://discuss.leetcode.com/topic/68845/c-solution-with-explanation</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> count=<span class="number">0</span>, repeat=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.size();i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;grid[i].size();j++)</div><div class="line">                &#123;</div><div class="line">                    <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</div><div class="line">                    &#123;</div><div class="line">                        count ++;</div><div class="line">                        <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; grid[i<span class="number">-1</span>][j] == <span class="number">1</span>) repeat++;</div><div class="line">                        <span class="keyword">if</span>(j!=<span class="number">0</span> &amp;&amp; grid[i][j<span class="number">-1</span>] == <span class="number">1</span>) repeat++;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">4</span>*count-repeat*<span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong><br>总周长perimeter的解法一般两种：</p>
<pre><code>1. “1”元素总长-相邻边×2
2. perimeter=边界元素个数+与“0”相邻元素个数
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/island-perimeter/description/&quot; t
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="BFS" scheme="http://skyhacks.org/tags/BFS/"/>
    
      <category term="DFS" scheme="http://skyhacks.org/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 200. Number of Islands</title>
    <link href="http://skyhacks.org/2017/11/17/LeetCode/LeetCode-NumberofIslands/"/>
    <id>http://skyhacks.org/2017/11/17/LeetCode/LeetCode-NumberofIslands/</id>
    <published>2017-11-17T01:40:59.000Z</published>
    <updated>2017-11-20T13:16:51.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="external">题目描述</a>：</h2><p>Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.<br><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11110</div><div class="line">11010</div><div class="line">11000</div><div class="line">00000</div></pre></td></tr></table></figure></p>
<p>Answer: 1<br><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">11000</div><div class="line">11000</div><div class="line">00100</div><div class="line">00011</div></pre></td></tr></table></figure></p>
<p>Answer: 3</p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个由字符‘1’（陆地）和‘0’（水域）组成的二维网格地图，计算岛屿的个数。岛屿被水域环绕，由竖直或者水平方向邻接的陆地构成。你可以假设网格地图的四条边都被水域包围。<br>测试样例见题目描述</p>
<h3 id="解题思路1："><a href="#解题思路1：" class="headerlink" title="解题思路1："></a>解题思路1：</h3><hr>
<p>DFS：深度优先遍历（递归实现）<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/106261/java-c-clean-code" target="_blank" rel="external">https://discuss.leetcode.com/topic/106261/java-c-clean-code</a><br><a href="https://discuss.leetcode.com/topic/13045/my-accepted-c-solution-may-be-trivial" target="_blank" rel="external">https://discuss.leetcode.com/topic/13045/my-accepted-c-solution-may-be-trivial</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == grid.size() || <span class="number">0</span> == grid[<span class="number">0</span>].size())</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numIslands = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">'1'</span> == grid[i][j]) &#123;</div><div class="line">                    numIslands++;</div><div class="line">                    bfs(grid, i, j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numIslands;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> &gt; i || i &gt;= grid.size() || <span class="number">0</span> &gt; j || j &gt;= grid[<span class="number">0</span>].size() || <span class="string">'0'</span> == grid[i][j])</div><div class="line">            <span class="keyword">return</span>;</div><div class="line"></div><div class="line">        grid[i][j] = <span class="string">'0'</span>; <span class="comment">// mark the value to avoid duplication</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir(&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;); <span class="comment">// c++11/14</span></div><div class="line">        <span class="comment">// int nums[] = &#123;-1, 0, 1, 0, -1&#125;;</span></div><div class="line">        <span class="comment">// vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int));</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; dir.size() - <span class="number">1</span>; idx++) &#123;</div><div class="line">            <span class="keyword">int</span> rowIdx = i + dir[idx]; <span class="comment">// row index</span></div><div class="line">            <span class="keyword">int</span> colIdx = j + dir[idx + <span class="number">1</span>]; <span class="comment">// col index</span></div><div class="line">            dfs(grid, rowIdx, colIdx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. 递归函数需要注意结束条件，即边界的处理。我们关心的是grid范围内，其值为1的元素
2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0
3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)]
4. 由于是字符数组，在dfs迭代过程中，先要判断是否存在空数组情况，即‘[]’.
</code></pre><h3 id="解题思路2："><a href="#解题思路2：" class="headerlink" title="解题思路2："></a>解题思路2：</h3><hr>
<p>BFS：广度优先遍历（借助队列迭代实现）<br>参考LeetCode Discuss：<br><a href="https://discuss.leetcode.com/topic/11589/dfs-and-bfs-in-c" target="_blank" rel="external">https://discuss.leetcode.com/topic/11589/dfs-and-bfs-in-c</a></p>
<p><strong>C++代码：</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="number">0</span> == grid.size() || <span class="number">0</span> == grid[<span class="number">0</span>].size())</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> numIslands = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">'1'</span> == grid[i][j]) &#123;</div><div class="line">                    numIslands++;</div><div class="line">                    bfs(grid, i, j);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> numIslands;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</div><div class="line">        q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(i, j));</div><div class="line">        grid[i][j] = <span class="string">'0'</span>; <span class="comment">// mark the value to avoid duplication</span></div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dir(&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;); <span class="comment">// c++11/14</span></div><div class="line">        <span class="comment">// int nums[] = &#123;-1, 0, 1, 0, -1&#125;;</span></div><div class="line">        <span class="comment">// vector&lt;int&gt; dir(nums, nums + sizeof(nums) / sizeof(int));</span></div><div class="line">        <span class="keyword">while</span> (<span class="number">0</span> &lt; q.size()) &#123;</div><div class="line">            <span class="keyword">int</span> m = q.front().first; <span class="comment">// row index</span></div><div class="line">            <span class="keyword">int</span> n = q.front().second; <span class="comment">// col index</span></div><div class="line">            q.pop(); <span class="comment">// remove from queue</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; dir.size() - <span class="number">1</span>; idx++) &#123;</div><div class="line">                <span class="keyword">int</span> rowIdx = m + dir[idx];</div><div class="line">                <span class="keyword">int</span> colIdx = n + dir[idx + <span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span> (<span class="number">0</span>&lt;=rowIdx &amp;&amp; rowIdx&lt;grid.size() &amp;&amp; <span class="number">0</span>&lt;=colIdx &amp;&amp; colIdx&lt;grid[<span class="number">0</span>].size()</div><div class="line">                    &amp;&amp; <span class="string">'1'</span>==grid[rowIdx][colIdx]) &#123;</div><div class="line">                    q.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(rowIdx, colIdx));</div><div class="line">                    grid[rowIdx][colIdx] = <span class="string">'0'</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><strong>代码分析：</strong></p>
<pre><code>1. BFS的处理需要借助数组实现，每一次将grid范围内其值为1的元素塞进数组（后续元素为当前grid[i][j]四个方向上的邻接元素）
2. 为避免重复计数，每统计一个grid[i][j]，将其值置为0
3. 由于孤岛有四个维度，元素grid[i][j]的四个方向的下一个元素坐标分别为：[(i-1, j), (i+1, j), (i, j-1), (i, j+1)]
4. 由于是字符数组，在dfs迭代过程中，先要判断是否存在空数组情况，即‘[]’.
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/number-of-islands/description/&quot; 
    
    </summary>
    
      <category term="LeetCode" scheme="http://skyhacks.org/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://skyhacks.org/tags/LeetCode/"/>
    
      <category term="Algorithms" scheme="http://skyhacks.org/tags/Algorithms/"/>
    
      <category term="Data Structure" scheme="http://skyhacks.org/tags/Data-Structure/"/>
    
      <category term="Array" scheme="http://skyhacks.org/tags/Array/"/>
    
      <category term="BFS" scheme="http://skyhacks.org/tags/BFS/"/>
    
      <category term="DFS" scheme="http://skyhacks.org/tags/DFS/"/>
    
  </entry>
  
</feed>
